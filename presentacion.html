<!DOCTYPE html>
<html lang="es">
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
<meta content="Asciidoctor 1.5.3" name="generator">
<meta content="Javier Gómez Santos" name="author">
<title>Lenguaje C++</title>
<link href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/7.3/styles/solarized_dark.min.css" rel="stylesheet">
<script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/7.3/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
<link href="deck.js/core/deck.core.css" rel="stylesheet">
<link href="deck.js/extensions/scale/deck.scale.css" media="screen" rel="stylesheet">
<link href="deck.js/extensions/goto/deck.goto.css" media="screen" rel="stylesheet">
<link href="deck.js/extensions/menu/deck.menu.css" media="screen" rel="stylesheet">
<link href="deck.js/extensions/navigation/deck.navigation.css" media="screen" rel="stylesheet">
<link href="deck.js/extensions/status/deck.status.css" media="screen" rel="stylesheet">
<link href="deck.js/extensions/toc/deck.toc.css" media="screen" rel="stylesheet">
<link href="deck.js/themes/style/web-2.0.css" media="screen" rel="stylesheet">
<link href="deck.js/themes/transition/horizontal-slide.css" media="screen" rel="stylesheet">
<link href="deck.js/core/print.css" media="print" rel="stylesheet">
<script src="deck.js/modernizr.custom.js"></script>
</head>
<body class="article">
<div class="deck-container">
<section class="slide" id="title-slide">
<h1>Lenguaje C++</h1>

<br>
</section>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p><span class="image thumb left" style="float: right"><img alt="logo curso" src="images/icons/c_0.png" width="100"></span></p></div>
</div>
</div>
<section class="slide" id="_contenidos">
<h2>Contenidos</h2>
<div class="olist arabic">
<ol class="arabic">
<li>
Introducción al C++
</li>
<li>
Primeros pasos en C++
</li>
<li>
Bases del lenguaje C++ (variables, operadores, tipos)
</li>
<li>
Bases del lenguaje C++ (control de flujo)
</li>
<li>
Prácticas I
</li>
<li>
Arrays y punteros
</li>
<li>
Prácticas II
</li>
<li>
Programación Orientada a Objetos
</li>
<li>
Prácticas III, la lista enlazada
</li>
<li>
Sobrecarga de operadores
</li>
<li>
Agregación, composición, inicializadores de constructor
</li>
<li>
Herencia
</li>
<li>
Funciones virtuales
</li>
<li>
Trabajando con ficheros
</li>
<li>
Plantillas (templates)
</li>
<li>
Excepciones
</li>
<li>
STL
</li>
</ol>
</div>
</section>
<section class="slide" id="_objetivos">
<h2>Objetivos</h2>
<div class="ulist">
<ul>
<li>El objetivo del curso es el de dotar al alumno de las <strong>competencias necesarias</strong> para entender el lenguaje C++ y realizar aplicaciones orientadas a objetos</li>
</ul>
</div>
</section>
<section class="slide" id="_1_introducción_al_c">
<h2>1. Introducción al C++</h2>
<div class="olist arabic">
<ol class="arabic">
<li>
Historia
</li>
<li>
Versiones de C++
</li>
<li>
Filosofía de la programación orientada a objetos
</li>
<li>
Pero si Java está en todos sitios, ¿Por qué usar C++?
</li>
</ol>
</div>
</section>
<section class="slide" id="_historia">
<h2>Historia</h2>
<div class="ulist">
<ul>
<li>El lenguaje <strong>C</strong> se creó en 1972 por Dennis Ritchie (Laboratorios Bell de AT&amp;T) , a partir del lenguaje <strong>B</strong>, con la finalidad de recodificar el sistema operativo <strong>UNIX</strong></li>
<li>Durante muchos años no existen reglas estándar para el lenguaje, pero en 1983 se decide formar un comité con el objetivo de crear el estándar ANSI (Instituto Nacional Americano de Estándares).</li>
<li>A principios de los 90 el estándar es reconocido por la ISO (Organización Internacional de Estándares) y comienza a comercializarse con el nombre ANSI C.</li>
</ul>
</div>
<div style="page-break-after: always"></div>
<div class="ulist">
<ul>
<li>Paralelamente, en 1980 surge C++ de la mano de Bjarne Stroustrup (Laboratorios Bell de AT&amp;T), con el objetivo de añadir a C clases y funciones virtuales (de SIMULA67), tipos genéricos y expresiones (de ADA), la posibilidad de declarar variables en cualquier punto del programa (de ALGOL68) y  un auténtico motor de objetos con herencia múltiple</li>
<li>En 1990 se reúnen las organizaciones ANSI e ISO para definir un estándar que formalice el lenguaje. El proceso culmina en 1998 con la aprobación del ANSI C++.</li>
<li>A partir de entonces, se han ido realizando distintas actualizaciones del estancar C++</li>
</ul>
</div>
</section>
<section class="slide" id="_versiones_de_c">
<h2>Versiones de C++</h2>
<div class="paragraph"><p>Contrariamente a lo que sucede en otros lenguajes, C++ no evoluciona en versiones, si no en revisiones de su estándar, en los que se da el visto bueno a la evolución del C++ en su nuevo "dialecto"
Por lo tanto, se denonima C++XY a la revisión del C++ que fue aprobada en el año indicado por XY.</p></div>
<div class="ulist">
<ul>
<li><strong>C++98</strong> Primera versión de C++ aprobada por ISO</li>
<li><strong>C++03</strong> No incluye cambios en el <strong>core</strong>, modificaciones internas que no afectan al código</li>
<li><p>
<strong>C++07/TR1</strong> No fue un estándar en si mismo, si no unas mejoras sobre el estándar anterior<div class="ulist">
<ul>
<li>Expresiones regulares</li>
<li>punteros inteligentes</li>
<li>tablas hash</li>
<li>generadores de números aleatorios</li>
</ul>
</div></p></li>
</ul>
</div>
<div style="page-break-after: always"></div>
<div class="ulist">
<ul>
<li><p>
<strong>C++11</strong> No incluye cambios en el <strong>core</strong>, modificaciones internas que no afectan al código<div class="ulist">
<ul>
<li>Funciones Lambda</li>
<li>Tipos de datos autodetectados por el compilador</li>
<li>Los constructores pueden llamar a otros</li>
<li>Listas de inicialización de objetos</li>
</ul>
</div></p></li>
<li><p>
<strong>C++14</strong> el último estándar hasta la fecha<div class="ulist">
<ul>
<li>arrays de tamaño calculado</li>
<li>deducción del tipo devuelto por funciones</li>
<li>variables plantilla</li>
<li>inicializadores de miembros agregados</li>
</ul>
</div></p></li>
</ul>
</div>
</section>
<section class="slide" id="_filosofía_de_la_programación_orientada_a_objetos">
<h2>Filosofía de la programación orientada a objetos</h2>
<div class="paragraph"><p>La programación orientada a objetos (POO, u OOP según sus siglas en inglés) es un paradigma de programación que usa objetos en sus interacciones, para diseñar aplicaciones y programas informáticos.</p></div>
<div class="paragraph"><p>Los objetos son entidades que tienen un determinado "estado", "comportamiento (método)" e "identidad":</p></div>
<div class="ulist">
<ul>
<li>El estado está compuesto de datos o informaciones; serán uno o varios atributos a los que se habrán asignado unos valores concretos (datos).</li>
<li>El comportamiento está definido por los métodos o mensajes a los que sabe responder dicho objeto, es decir, qué operaciones se pueden realizar con él.</li>
<li>La identidad es una propiedad de un objeto que lo diferencia del resto; dicho con otras palabras, es su identificador (concepto análogo al de identificador de una variable o una constante).</li>
</ul>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>La finalidad de la POO es la encapsulación, es decir, definir unidades funcionales completas que interaccionen entre si, como si fueran cajas negras. Sabemos cómo interactuar con dichas cajas negras, pero no todo lo que ha sido programado en dicha clase es accesible externamente.
Adicionalmente, la POO también establece relaciones entre distintas clases.</p></div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="POO" src="images/pics/POO.jpg">
</div>
</div>
</section>
<section class="slide" id="_pero_si_java_está_en_todos_sitios_por_qué_usar_c">
<h2>Pero si Java está en todos sitios, ¿Por qué usar C++?</h2>
<div class="paragraph"><p>Un programa es un conjunto de instrucciones que queremos dar a un computador, pero los procesadores trabajan con <strong>código máquina</strong>, y es propio de cada procesador o familia de procesadores. Nuestros programas están escritos de manera legible, por lo que no son ejecutables directamente por una máquina. Las alternativas son:</p></div>
<div class="ulist">
<ul>
<li>Tener un programa que <strong>compila</strong> nuestro código a código máquina, cuyo resultado está vinculado a la arquitectura y Sistema Operativo destino (C++, Pascal, Basic&#8230;&#8203;)</li>
<li>Tener un programa que <strong>interpreta</strong> dicho código y lo ejecuta automáticamente (Python, Perl, Haskell)</li>
<li>Compilar el programa a un código máquina ficticio e interpretar dicho código con un programa (Java, Groovy, Scala)</li>
</ul>
</div>
<div class="imageblock" style="text-align: text-left; float: left">
<div class="content">
<img alt="CompiledExecutable" src="images/diagrams/CompiledExecutable.png">
</div>
<div class="title">Figure 1. Compilar</div>
</div>
<div class="imageblock" style="text-align: text-left; float: right">
<div class="content">
<img alt="Interpreted" src="images/diagrams/Interpreted.png">
</div>
<div class="title">Figure 2. Interpretar</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Las ventajas de usar Java son muchas, enfocadas a la portabilidad. Para ser un lenguaje "pseudo-interpretado", tiene un rendimiento muy bueno, pero no puede llegar a alcanzar el rendimiento de un lenguaje compilado (con un compilador bueno). Además, Java, para alcanzar dicho rendimiento, debe haber <strong>calentado</strong> el código, por lo que no tendremos el rendimiento óptimo al arrancar el programa.</p></div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="benchmark" src="images/diagrams/benchmark.PNG">
</div>
<div class="title">Figure 3. Paper "Loop Recognition in C++/Java/Go/Scala", by Robert Hundt @Google</div>
</div>
</section>
<section class="slide" id="_2_primeros_pasos_en_c">
<h2>2. Primeros pasos en C++</h2>
<div class="olist arabic">
<ol class="arabic">
<li>
Introducción al desarrollo
</li>
<li>
Usando el compilador del sistema
</li>
<li>
Instalando un IDE de desarrollo
</li>
<li>
Abrocharse el cinturón, ¡que empezamos!
</li>
</ol>
</div>
</section>
<section class="slide" id="_introducción_al_desarrollo">
<h2>Introducción al desarrollo</h2>
<div class="paragraph"><p>Las fases del desarrollo en C++</p></div>
<div class="ulist">
<ul>
<li>1 - Definir el problema</li>
<li>2 - Buscar una solución</li>
<li>3 - Codificar dicha solución</li>
<li>4 - Compilar el programa</li>
<li>5 - Enlazar (link) los objetos compilados</li>
<li>6 - Probar y depurar</li>
</ul>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Varias de estas fases de explican por si solas, y ya estamos acostumbrados a trabajar con ellas, pero vamos a pararnos entre las fases <strong>Compilación</strong> y <strong>Enlazado</strong></p></div>
<div class="ulist">
<ul>
<li>Compilación</li>
</ul>
</div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="Compile" src="images/diagrams/Compile.png">
</div>
<div class="title">Figure 4. g++ -c file1.cpp file2.cpp file3.cpp</div>
</div>
<div class="paragraph"><p><br/></p></div>
<div class="ulist">
<ul>
<li>Enlazado</li>
</ul>
</div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="Link" src="images/diagrams/Link.png">
</div>
<div class="title">Figure 5. g++ -o prog file1.o file2.o file3.o</div>
</div>
<div class="paragraph"><p><br/></p></div>
<div class="paragraph"><p>Estos pasos pueden ser realizados con una sola instrucción g++ -o prog file1.cpp file2.cpp file3.cpp</p></div>
</section>
<section class="slide" id="_usando_el_compilador_del_sistema">
<h2>Usando el compilador del sistema</h2>
<div class="paragraph"><p>Podemos usar el compilador existente en nuestro sistema operativo <strong>g++</strong> o <strong>gcc</strong> (Cuidado, este últino no enlaza con la <strong>std</strong> directamente).</p></div>
<div class="paragraph"><p>Vamos a hacer una pequeña prueba, vamos a crear un fichero llamado <strong>HolaMundo.cpp</strong>, y vamos a escribir este contenido:</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;iostream&gt;
int main(){
    std::cout &lt;&lt; "Hola Mundo\r";
	return 0;
}</code></pre>
</div>
</div>
<div class="paragraph"><p>Ahora, vamos a compilar el programa y ejecutarlo</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="bat language-bat">C:\Carpeta&gt;g++ -o Hola.exe HolaMundo.cpp

C:\Carpeta&gt;Hola.exe
Hola Mundo</code></pre>
</div>
</div>
</section>
<section class="slide" id="_instalando_un_ide_de_desarrollo">
<h2>Instalando un IDE de desarrollo</h2>
<div class="paragraph"><p>Existen varios entornos de desarrollo para C++, los más conocidos son:</p></div>
<div class="ulist">
<ul>
<li><strong>Code::Blocks</strong>, que sirve tanto para Linux como para Windows</li>
<li><strong>Bloodshed's Dev-C++</strong>, que también es multiplataforma</li>
<li><strong>eclipse</strong>, que no trae soporte por defecto para C++, pero se puede añadir mediante plugins</li>
<li><strong>Visual Studio</strong> (Windows), dependiendo del espacio disponible, se puede optar por la versión <strong>Express</strong> o la <strong>Community</strong></li>
</ul>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>En este curso vamos a trabajar con la <strong>Visual Studio Community 2015</strong>, y como dicho IDE da soporte a varios lenguajes, es importante marcar que vamos a desarrollar en dicho lenguaje (y si queremos, podemos añadir hasta soporte para programar aplicaciones para dispositivos móviles)</p></div>
<div class="imageblock" style="text-align: text-left; float: left">
<div class="content">
<img alt="VS2015CommunityCustom" src="images/pics/VS2015CommunityCustom.jpg">
</div>
<div class="title">Figure 6. Instalación 1</div>
</div>
<div class="imageblock" style="text-align: text-left; float: left">
<div class="content">
<img alt="VS2015CommunityLangs" src="images/pics/VS2015CommunityLangs.jpg">
</div>
<div class="title">Figure 7. Instalación 2</div>
</div>
</section>
<section class="slide" id="_abrocharse_el_cinturón_que_empezamos">
<h2>Abrocharse el cinturón, ¡que empezamos!</h2>
<div class="paragraph"><p>Vamos a comenzar a trabajar con Visual Studio.</p></div>
<div class="paragraph"><p>Lo primero que vamos a hacer es arrancar Visual Studio, y crear un nuevo proyecto</p></div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="np 01" src="images/pics/np_01.PNG">
</div>
<div class="title">Figure 8. Nuevo Proyecto</div>
</div>
<div class="paragraph"><p>Ahora, elegimos <strong>Visual C++</strong> &#8594; <strong>Win32</strong> y <strong>New Console Application</strong></p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Nombramos nuestro proyecto y pulsamos <strong>OK</strong></p></div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="np 02" src="images/pics/np_02.PNG">
</div>
<div class="title">Figure 9. Datos de Nuevo Proyecto</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Por motivos de compatibilidad, vamos a desmarcar <strong>Precompiled header</strong> y pulsamos en <strong>Finish</strong></p></div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="np 03" src="images/pics/np_03.PNG">
</div>
<div class="title">Figure 10. Application Wizard para crear el proyecto</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Reemplazamos el código auto-generado por el usado en el ejemplo anterior, y guardamos</p></div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="np 04" src="images/pics/np_04.PNG">
</div>
<div class="title">Figure 11. Application Wizard para crear el proyecto</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Ahora, vamos a compilar y probar nuestro código</p></div>
<div class="ulist">
<ul>
<li>Para compilar nuestro código, en el menú <strong>Build</strong> &#8594; <strong>Build Solution</strong> (o Ctrl+Shift+B)</li>
</ul>
</div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="np 05" src="images/pics/np_05.PNG">
</div>
</div>
<div class="ulist">
<ul>
<li>Para ejecutar nuestro programa, en el menú <strong>Debug</strong> &#8594; <strong>Start Debugging</strong> (F5) o <strong>Debug</strong> &#8594; <strong>Start Without Debugging</strong> (Ctrl+F5)</li>
</ul>
</div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="np 06" src="images/pics/np_06.PNG">
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Por último, vamos a tener en cuenta las <strong>Build Configuration</strong>, o lo que es lo mismo, si vamos a compilar nuestro programa como versión <strong>Debug</strong> (sobre la que podremos realizar seguimiento paso a paso de nuestro software), o como versión <strong>Release</strong>.
Evidentemente la versión <strong>Release</strong> es mucho más eficiente</p></div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="np 07" src="images/pics/np_07.PNG">
</div>
</div>
<div class="paragraph"><p>También tenemos la opción de compilar para arquitectura <strong>x86</strong> o <strong>x64</strong></p></div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="np 08" src="images/pics/np_08.PNG">
</div>
</div>
</section>
<section class="slide" id="_3_bases_del_lenguaje_c_variables_operadores_tipos">
<h2>3. Bases del lenguaje C++ (variables, operadores, tipos)</h2>
<div class="olist arabic">
<ol class="arabic">
<li>
Comentarios
</li>
<li>
Declaración de variables
</li>
<li>
Constantes
</li>
<li>
Entrada y Salida Estándar con cin y cout
</li>
<li>
Operadores
</li>
<li>
Bloques, ámbitos y duración
</li>
<li>
namespace
</li>
<li>
conversión de tipos, casting
</li>
<li>
clases numeradas (enum class) (C++11)
</li>
<li>
estructuras (struct)
</li>
<li>
auto (C++11)
</li>
</ol>
</div>
</section>
<section class="slide" id="_comentarios">
<h2>Comentarios</h2>
<div class="paragraph"><p>Para realizar comentarios en <strong>C++</strong> podemos usar <strong>//</strong> para comentar el resto de la línea, o bien el comentario en bloque que se inicia con <strong>/*</strong> y se finaliza con <strong>*/</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main(){
    int x=9; //esto es un comentario de una línea
	if (x&gt;20)
	{
		/*esto es un comentario en bloque
		puede ocupar varias líneas
		sin ningú problema*/
		std::cout &lt;&lt; "Es mayor" &lt;&lt; std::endl;
	}
	return 0;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_declaración_de_variables">
<h2>Declaración de variables</h2>
<div class="paragraph"><p>Las variables se pueden declarar en C++ en cualqueir parte del código, se declaran indicando el tipo y posteriormente el nombre de la variable. (En <strong>C++11</strong> se ha añadido el tipo <strong>auto</strong>, que permite que el compilador asigne el tipo automáticamente a la variable)</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main(){
    /*Ejemplos de declaración de variables*/
	int x=0;//se declara una variable de tipo int, de nombre x
	int y(5);//se declara la variable y con valor 5, de tipo int
	char c='c';//se declara una variable de tipo char de nombre c
}</code></pre>
</div>
</div>
<div class="paragraph"><p>Importante también tener en cuenta que las variables ocupan distintos tamaños (en función de su tipo). Mediante la función <strong>sizeof()</strong>, podemos obtener su tamaño.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main(){
	int x=0;//se declara una variable de tipo int, de nombre x
	std::cout &lt;&lt; "El tamaño de X es " &lt;&lt; sizeof(x) &lt;&lt; " Bytes" &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<table class="tableblock frame-all grid-all" style="width:100%">
<caption class="title">Table 1. Table Tipos Fundamentales en C++</caption>
<colgroup>
<col style="width:33%">
<col style="width:33%">
<col style="width:33%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Tipo</th>
<th class="tableblock halign-left valign-top">Tamaño</th>
<th class="tableblock halign-left valign-top">Precisión</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 byte</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true o false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">char</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 byte</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 carácter (0-255)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">unsigned short int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">de 0 a 65.535</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">short int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">de -32.768 a 32.767</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">long int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">de -2.147.483.648 a 2.147.483.647</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">unsigned long int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">de 0 a 4.294.967.295</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">unsigned int (16 bites)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">de  0 a 65.535</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">unsigned int (32 bites)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">de  0 a 4.294.967.295</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int (16 bites)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">de -32.768 a 32.767</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int (32 bites)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">de -2.147.483.648 a 2.147.483.647</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">de 2.2e-308 a 3.4e-38.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">de  1.2e-308 a 3.4e-38</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Significa "Sin tipo"</p></td>
</tr>
</tbody>
</table>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>El tamaño de una variable de tipo <strong>int</strong> depende de la arquitectura sobre la que se compile el programa, para evitar estas discrepancias y hacer el código portable con mayor facilidad, se han definido una serie de tipos enteros con tamaño fijo (añadido en el estándar <strong>C++11</strong>)</p></div>
<table class="tableblock frame-all grid-all" style="width:100%">
<caption class="title">Table 2. Table Enteros con tamaños fijos</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Tipo</th>
<th class="tableblock halign-left valign-top">Tamaño</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int8_t</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 byte con signo</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint8_t</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 byte sin signo</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int16_t</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 byte con signo</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint16_t</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 byte sin signo</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int32_t</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 byte con signo</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint32_t</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 byte sin signo</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int64_t</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8 byte con signo</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint64_t</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8 byte sin signo</p></td>
</tr>
</tbody>
</table>
</section>
<section class="slide" id="_constantes">
<h2>Constantes</h2>
<div class="paragraph"><p>Imaginemos el siguiente fragmento de código, que representa una función que añade el IVA a un producto</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">double aplicaIva(double precio){
    return precio*1.21;
}</code></pre>
</div>
</div>
<div class="paragraph"><p>En esta función hay una práctica poco recomendable, escribir directamente en el código el valor del IVA aplicado. Esto es lo que llamamos <strong>Hardcodear</strong>. ¿Qué pasa si el día de mañana cambia el IVA? ¿Y si queremos hacer uso de ese valor en más sitios?
Para evitar esto, usaremos constantes</p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>En <strong>C++</strong> existen dos formas de definir constantes, mediante <strong>macros</strong> del pre-procesador y mediante la palabra reservada <strong>const</strong></p></div>
<div class="paragraph"><p>Mediante macros</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#define IVA_TIPO_3 1.21
double aplicaIva(double precio){
    return precio*IVA_TIPO_3;
}</code></pre>
</div>
</div>
<div class="paragraph"><p>Mediante const</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">const double IVA_TIPO_3 1.21

double aplicaIva(double precio){
    return precio*IVA_TIPO_3;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Los ejemplos propuestos pueden dar un mismo resultado, pero no lo obtienen de la misma manera. En el caso de <strong>const</strong>, el compilador crea un programa con una variable (con el nombre que hayamos dado), no se permite su reescritura y en tiempo de ejecución se obtiene su valor para obtener el resultado.
En el caso de la <strong>macro</strong>, el preprocesador busca en el código fuente cualquier ocurrencia de dicha cadena de texto y lo sustituye por el valor que hayamos indicado (su código compilado podría ser igual al que hayamos usado en caso de <strong>hardcodear</strong> los valores)</p></div>
<div class="paragraph"><p>Por lo tanto, para definir constantes, es recomendable hacer uso siempre de la palabra reservada <strong>const</strong></p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>¿Quiere decir esto que no debemos usar nunca la macro <strong>define</strong>? No, es de mucha utilidad. Por ejemplo, se suele usar para evitar declarar 2 veces lo mismo o para compilar códigos en función de unas variables definidas. Imaginemos el siguiente código:</p></div>
<div class="paragraph"><p>impuestos.h</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#ifndef IMPUESTOS_H
#define IMPUESTOS_H
namespace impuestos
{
	const double IVA_TIPO_3(1.21);
	const double IVA_TIPO_2(1.08);
	const double IVA_TIPO_1 = 1.04;
	const double SIN_IVA = 1;
}
#endif</code></pre>
</div>
</div>
<div class="paragraph"><p>Aunque tengamos varios archivos, que hagan uso de dicho fichero, no se definirán más de 1 vez las constantes</p></div>
<div class="paragraph"><p>aplicaIva.cpp</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include "impuestos.h"

double aplicaIva(double precio){
    return precio * impuestos::IVA_TIPO_3;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Cabe resaltar, que además de usar las macros <strong>#ifndef</strong> y <strong>#define</strong>, también podemos usar la macro <strong>#pragma once</strong>, que evita que se procese nuevamente el fichero si ya se ha procesado (por lo que aumenta la velocidad de compilación), pero aunque dicha directiva tiene un soporte extendido <strong>no es parte del estándar</strong></p></div>
<div class="paragraph"><p>impuestos.h</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#pragma once
namespace impuestos
{
	const double IVA_TIPO_3(1.21);
	const double IVA_TIPO_2(1.08);
	const double IVA_TIPO_1 = 1.04;
	const double SIN_IVA = 1;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_entrada_y_salida_estándar_con_cin_y_cout">
<h2>Entrada y Salida Estándar con cin y cout</h2>
<div class="paragraph"><p>La librería <strong>iostream</strong> incluye utilidades para poder realizar comunicación a través de la entrada y salida estándar. es para ello que define un namespace llamado <strong>std</strong>, dentro del cuál se definen <strong>cin</strong> y <strong>cout</strong>.</p></div>
<div class="ulist">
<ul>
<li><strong>cin</strong> equivale a la entrada estándar (presumiblemente el usuario, a través de un teclado)</li>
<li><strong>cout</strong> equivale a la salida estándar (presumiblemente, la consola donde se ejecuta el proceso)</li>
</ul>
</div>
<div class="paragraph"><p>En ambos casos, para interaccionar con ellos necesitamos hacer uso de <strong><<</strong> y <strong>>></strong>, operadores <strong>sobrecargados</strong> para trabajar con <strong>cout</strong> y <strong>cin</strong> respectivamente</p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Anteriormente ya hemos hecho uso de <strong>cout</strong>, pero para ello debemos indicar a nuestro proceso dónde debe buscar dicho elemento (en nuestro caso en <strong>std</strong>). Para ello hemos usado el <strong>::</strong>, también llamado <strong>Scope Resolution Operator</strong>.
Vamos a modificar el ejemplo anterior para pedir al usuario el precio del producto del que queremos calcular el IVA.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
	double precio;
	std::cout &lt;&lt; "Introduzca el precio: ";
	std::cin &gt;&gt; precio;
	std::cout &lt;&lt; "Precio con IVA = " &lt;&lt; aplicaIva(precio) &lt;&lt; std::endl;
    return 0;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>En ocasiones, queremos hacer uso de un namespace con bastante frecuencia, como puede ser el uso de <strong>std</strong>, y queremos ahorrar tiempo al escribir código.</p></div>
<div class="paragraph"><p>En <strong>C++</strong> se puede especificar que en el ámbito actual (fichero, función&#8230;&#8203;) se busquen en los namespaces indicados. Para ello usaremos la instrucción <strong>using namespace XX</strong>, donde XX es el namespace sobre el que queremos trabajar. Esto se ve mejor con un ejemplo</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
	double precio;
	std::cout &lt;&lt; "Introduzca el precio: ";
	using namespace std;
	cin &gt;&gt; precio;
	cout &lt;&lt; "Precio con IVA = " &lt;&lt; aplicaIva(precio) &lt;&lt; endl;
    return 0;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>¿Y la salida de <strong>error</strong>?</p></div>
<div class="paragraph"><p>Si habéis trabajado en <strong>Unix</strong>, recordaréis que las <strong>E/S</strong> estándar eran tres, entrada estándar, salida estándar y salida de error.</p></div>
<div class="paragraph"><p>Esta salida de <strong>error</strong> también existe en <strong>C++</strong>, se accede mediante <strong>cerr</strong>, y su uso es análogo a <strong>cout</strong>.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{

	std::cerr &lt;&lt; "Error Terrible"&lt;&lt; std::endl;
    return 0;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_operadores">
<h2>Operadores</h2>
<div class="paragraph"><p>Operadores aritméticos</p></div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="Table5.1.ArithmeticOperators thumb1" src="images/pics/Table5.1.ArithmeticOperators_thumb1.png">
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Operadores Lógicos</p></div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="Table5.2.RelationalandLogicalOperato" src="images/pics/Table5.2.RelationalandLogicalOperato.png">
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Operadores a nivel de bit</p></div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="Table5.3.BitwiseOperators thumb1" src="images/pics/Table5.3.BitwiseOperators_thumb1.png">
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Operadores de asignación aritméticos</p></div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="airthmetic assignment operator" src="images/pics/airthmetic_assignment_operator.PNG">
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Autoincrementadores y autodecrementadores</p></div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="autoincrementos" src="images/pics/autoincrementos.PNG">
</div>
</div>
<div style="page-break-after: always"></div>
<table class="tableblock frame-all grid-all" style="width:100%">
<caption class="title">Table 3. Table Otros operadores</caption>
<colgroup>
<col style="width:33%">
<col style="width:33%">
<col style="width:33%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Operador</th>
<th class="tableblock halign-left valign-top">Descripción</th>
<th class="tableblock halign-left valign-top">Ejemplo</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">agrupaciones</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(expresión)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">::</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Scope Resolution Operator</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">clase::miembro</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Acceso a miembro de objeto</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">objeto.miembro</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">-></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Acceso a miembro de un puntero de objeto</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">objeto->miembro</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&variable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">dirección de (devuelve un puntero)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">puntero=&variable;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">*variable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">desreferenciación (devuelve el objeto apuntado)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">variable=*puntero;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">?:</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Operador condicional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">expr ? x : y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sizeof()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">tamaño en bytes del tipo o variable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sizeof(x)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">,</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">evalúa ambos, devuelve el último</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">z=(x+2,y+1)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">{ }</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">definen un bloque de código</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{x=3;}</p></td>
</tr>
</tbody>
</table>
</section>
<section class="slide" id="_bloques_ámbitos_y_duración">
<h2>Bloques, ámbitos y duración</h2>
<div class="paragraph"><p>Cuando hablamos de <strong>bloques</strong> estamos hablando de bloques de instrucciones, es decir, un conjunto de instrucciones que van a ser tratadas por el compilador como una única unidad. Estos <strong>bloques</strong> se definen mediante los caracteres <strong>{</strong> y <strong>}</strong>.</p></div>
<div class="paragraph"><p>Hemos hecho uso de los <strong>bloques</strong> para definir el contenido de la función <strong>main</strong> en nuestro ejemplo, y también con la función para obtener el IVA, pero podemos usar bloques dentro de bloques.</p></div>
<div class="paragraph"><p>Un ejemplo clásico: el <strong>if</strong>. Esto es una instrucción que permite la ejecución de la siguiente instrucción en función de unas condiciones.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">if (x&gt;3)
{
	std::cout &lt;&lt; "Es mayor que 3" &lt;&lt; std::endl;
	std::cout &lt;&lt; "Es impar" &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">if (x&gt;3)
	std::cout &lt;&lt; "Es mayor que 3" &lt;&lt; std::endl;
	std::cout &lt;&lt; "Es impar" &lt;&lt; std::endl;</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>La <strong>ámbito</strong> de una variable, estamos haciendo referencia a dónde es accesible la misma. Cuando hablamos de <strong>duración</strong> hablamos de cuándo la variable existe (antes de su destrucción).
Que la variable exista no implica que sea accesible. Una variable va a existir desde el momento de su declaración, hasta la finalización del bloque donde se declara, pero puede no ser accesible si por ejemplo, se declara otro bloque interno con una variable del mismo nombre.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
	int x=3;
	int z=9;
	{
		int x=4;//esta declaración "oculta" la declaración previa de x
		std::cout &lt;&lt; x &lt;&lt; z &lt;&lt; std::endl;//imprimirá "49", pues z sigue siendo accesible
	}
	std::cout &lt;&lt; x &lt;&lt; z &lt;&lt; std::endl;//imprimirá "39" ya que la "redefinición" de x finaliza al finalizar su bloque
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Existe también la opción de realizar una declaración de variables en el propio fichero fuente, sin incluirlo en ningún bloque. Este tipo de variables las denominamos
<strong>variables globales</strong>, puesto que son accesibles desde cualquier lugar (siempre y cuando incluya dicho fichero fuente).
El uso de variables globales es, por lo general, muy poco recomendado (salvo para el caso de constantes), ya que cualquiera puede alterar dicha variable, y sería muy costoso asegurarnos que nadie hace un uso indebido de la misma.
Si tenemos necesidad de hacer uso de ellas, lo mejor será crear una clase con variables <strong>static</strong>, para controlar el acceso a la misma (ya veremos cómo).</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;iostream&gt;
int x=3;

int main()
{
	std::cout &lt;&lt; x &lt;&lt; std::endl;//imprimirá "3"
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Por añadir un poco de información, una variable declarada <strong>static</strong> sólo va a instanciarse una única vez. Dentro de una clase, cualquier atributo declarado
<strong>static</strong> va a valer lo mismo para cualquier instancia de la misma, incluso podemos acceder a él sin instancia de la clase. Hay que pensar en ellos como atributos propios de la clase y no de las instancias.
No obstante se puede usar <strong>static</strong> también dentro de un <strong>bloque</strong>. En este caso la variable se crea sólo la primera vez que se accede a dicho bloque, sin destruirse al finalizar (de tal manera que conservará su valor siempre.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;iostream&gt;
void funcionCuriosa()
{
static int x=0;
std::cout &lt;&lt; x++ &lt;&lt; std::endl;;
}
int main()
{
	funcionCuriosa();
	funcionCuriosa();
	funcionCuriosa();
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_namespace">
<h2>namespace</h2>
<div class="paragraph"><p>Imaginemos el siguiente ejemplo:</p></div>
<div class="paragraph"><p>impuestos.h</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">double aplicaIva(double precio) {
	return precio * 1.21;
}</code></pre>
</div>
</div>
<div class="paragraph"><p>utilidades.h</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">double aplicaIva(double precio) {
	return precio * 1.10;
}</code></pre>
</div>
</div>
<div class="paragraph"><p>programa.cpp</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;iostream&gt;
#include "impuestos.h"
#include "utilesImpuestos.h"

int main()
{
	std::cout &lt;&lt; "Precio con IVA = " &lt;&lt; aplicaIva(10) &lt;&lt; std::endl;
    return 0;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>El ejemplo anterior dará un error, debido a la ambigüedad existente entre las dos funciones aplicaIva. El compilador no sabe a cuál de las dos estamos haciendo referencia.
Cuando nuestros programas crecen es habitual que se puedan dar errores de este tipo. Para evitar <strong>conflictos</strong> de nombres (tanto en variables como en funciones), vamos a hacer uso de los <strong>namespace</strong>
Un <strong>namespace</strong> es un área de nuestro código donde todos los identificadores están garantizados como únicos.</p></div>
<div class="paragraph"><p>Hacer un <strong>namespace</strong> es muy sencillo, todo lo que queramos incluir en él vamos a envolverlo en un <strong>bloque</strong>, precedido de <strong>namespace XXX</strong>, donde <strong>XXX</strong> es el nombre de nuestro <strong>namespace</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">namespace miNamespace
{
	int x=0;
	int z=3;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Vamos a corregir el ejemplo anterior</p></div>
<div class="paragraph"><p>impuestos.h</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">namespace impuestos
{
	double aplicaIva(double precio) {
		return precio * 1.21;
	}
}</code></pre>
</div>
</div>
<div class="paragraph"><p>utilidades.h</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">namespace utilidades
{
	double aplicaIva(double precio) {
		return precio * 1.10;
	}
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Bueno, esto sigue sin funcionar, pero ahora debido a que no encuentra ninguna función con dicho nombre. Nos falta un último paso, indicarle al compilador en cuál de estos <strong>namespace</strong> debe buscar dicha función.</p></div>
<div class="paragraph"><p>programa.cpp</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;iostream&gt;
#include "impuestos.h"
#include "utilesImpuestos.h"

int main()
{
	std::cout &lt;&lt; "Precio con IVA = " &lt;&lt; impuestos::aplicaIva(10) &lt;&lt; std::endl;
    return 0;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_conversión_de_tipos_casting">
<h2>conversión de tipos, casting</h2>
<div class="paragraph"><p>Ya hemos visto que existen muchos tipos de datos en <strong>C++</strong>. En ocasiones, tenemos que hacer conversiones entre nuestros datos. Estas conversiones podemos dejarlas en manos del compilador, o podemos especifiarlas nosotros.</p></div>
<div class="paragraph"><p>Veamos un ejemplo</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;iostream&gt;

int main()
{
	double x=3.6;
	int z=x;
	std::cout &lt;&lt; z &lt;&lt; std::endl;
    return 0;
}</code></pre>
</div>
</div>
<div class="paragraph"><p>¿Qué ocurre al ejecutar?</p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>En el ejemplo anterior vimos cómo el compilador convertía automáticamente un tipo de dato en otro. De esta manera ese "3.6" pasaba a ser un "3" para poder almacenarse como un <strong>int</strong>.</p></div>
<div class="paragraph"><p>Vamos a ver otro ejemplo</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;iostream&gt;

int main()
{
	int dividendo=5;
	int divisor=2;
	double resultado= dividendo/divisor;
	std::cout &lt;&lt; resultado &lt;&lt; std::endl;
    return 0;
}</code></pre>
</div>
</div>
<div class="paragraph"><p>¿Qué ha pasado aquí?</p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>En el ejemplo anterior esperábamos que el compilador realizara una conversión de tipo <strong>double</strong> a <strong>int</strong>, y la ha hecho, ha cogido el resultado de la división y lo ha convertido.
El problema es que el resultado de operar con <strong>int</strong>, es siempre un <strong>int</strong>.
Podemos forzar al compilador a realizar una conversión de tipos, para ello indicaremos entre paréntesis el tipo al que queremos convertir nuestro dato.</p></div>
<div class="paragraph"><p>Corrijamos el ejemplo anterior</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;iostream&gt;

int main()
{
	int dividendo=5;
	int divisor=2;
	double resultado= (double)dividendo / (double)divisor;
	std::cout &lt;&lt; resultado &lt;&lt; std::endl;
    return 0;
}</code></pre>
</div>
</div>
<div class="paragraph"><p>(En realidad, con haber convertido uno de los 2 elementos ya habría sido suficiente)</p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>la conversión (o <strong>casting</strong>) que hemos realizado mediante los paréntesis es sólo una de las formas en las que <strong>C++</strong> nos permite hacer conversiones. No siempre son las más recomendables puesto que <strong>no</strong> son revisadas en tiempo de compilación</p></div>
<div class="paragraph"><p>Otra forma de realizar conversiones (más propia de <strong>C++</strong>) es indicando el tipo y la expresión a convertir (rodeada de paréntesis)</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;iostream&gt;

int main()
{
	int dividendo=5;
	int divisor=2;
	double resultado= double(dividendo) / double(divisor);
	std::cout &lt;&lt; resultado &lt;&lt; std::endl;
    return 0;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Existe una tercera forma de realizar el <strong>casting</strong> en <strong>C++</strong>, el <strong>static_cast</strong>. El uso de <strong>static_cast</strong> está enfocado a la conversión de un tipo fundamental a otro. Es menos potente que los cast anteriores pero realiza más comprobaciones en tiempo de compilación.</p></div>
<div class="paragraph"><p>Veamos como quedaría nuestro ejemplo mediante el uso de static_cast</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;iostream&gt;

int main()
{
	int dividendo=5;
	int divisor=2;
	double resultado= static_cast&lt;double&gt;(dividendo) / static_cast&lt;double&gt;(divisor);
	std::cout &lt;&lt; resultado &lt;&lt; std::endl;
    return 0;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Pero <strong>static_cast</strong> no es la única conversion aportada por <strong>C++</strong>, existen otros tres tipos, <strong>const_cast</strong>, <strong>dynamic_cast</strong> y <strong>reinterpret_cast</strong>.</p></div>
<div class="ulist">
<ul>
<li><strong>static_cast</strong> &#8594; Convierte punteros entre <strong>clases relacionadas</strong> (padre a hijo y viceversa)</li>
<li><strong>const_cast</strong> &#8594; permite convertir de un tipo de puntero <strong>const</strong> a su equivalente, y viceversa, útil por ejemplo si tienes un <strong>puntero const</strong> y la función no tiene especificado <strong>const</strong> en su cabecera. De todas maneras, no se puede modificar su valor.</li>
<li><strong>dynamic_cast</strong> &#8594; La conversión se verifica en tiempo de ejecución. Si es entre punteros y no se puede verificar, devuelve un <strong>null</strong>.</li>
<li><strong>reinterpret_cast</strong> &#8594; permite convertir de un tipo de puntero a cualquier otro tipo, aunque no estén relacionados.</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">void f (char * str){
	cout &lt;&lt; str &lt;&lt; '\n';}
int main () {
  const char * c = "algo";
  f ( const_cast&lt;char *&gt; (c) );
  return 0;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Por último, existe un <strong>operador</strong> llamado <strong>typeid</strong> que nos permite consultar el tipo de una variable. Su uso queda bastante autoexplicado en este ejemplo:</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main() {
	int a (5);
	int* ptr_a = &amp;a;
	float b(1.4);
	std::cout &lt;&lt; "ptr_a es: " &lt;&lt; typeid(ptr_a).name() &lt;&lt; std::endl;
	std::cout &lt;&lt; "b es: " &lt;&lt; typeid(b).name() &lt;&lt; std::endl;
	return 0;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_tipos_numerados_enum_y_typedef">
<h2>tipos numerados (enum) y typedef</h2>
<div class="paragraph"><p>En <strong>C++</strong> podemos definir nuestros propios tipos. Por ejemplo, podemos usar <strong>typedef</strong> para definir un alias a un tipo ya existente. Esto puede ser algo tan sencillo como dar un alias a un tipo fundamental como puede ser un <strong>int</strong>, pero puede ser mucho más complicado</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;iostream&gt;
typedef int entero;
typedef std::pair&lt;std::string, int&gt; pareja;

int main()
{
	entero e = 9;
	pareja p =  std::make_pair("hola",3);
	std::cout &lt;&lt; p.second &lt;&lt; " " &lt;&lt; e &lt;&lt; std::endl;
    return 0;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Imaginemos que tenemos un método que nos devuelve el estado civil de una persona. Estos valores van del 0 al 3. Es muy poco elegante tener que trabajar directamente con unos enteros, cuyos valores no aportan nada de claridad al código.</p></div>
<div class="paragraph"><p>Podemos hacer uso de <strong>enum</strong> para declarar un tipo enumerado, es decir, un <strong>alias</strong> para el tipo <strong>int</strong>, cuyos valores van a tener un equivalente como constante. Veamos con un ejemplo</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">enum estado{
	SOLTERO=0,
	CASADO=1,
	VIUDO=2,
	DIVORCIADO=3
};

estado dameEstado()
{
	return CASADO;
}</code></pre>
</div>
</div>
<div class="paragraph"><p><strong>IMPORTANTE</strong>, finaliza el enum con <strong>;</strong></p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>No es necesario asignar valores a cada uno de los <strong>estados</strong> que definimos, si no lo hacemos, el compilador automáticamente asigna 0 al primer estado y va incrementando el valor para cada estado.</p></div>
<div class="paragraph"><p>De hecho, si definimos un primer valor, el compilador irá incrementando uno a uno cada uno de ellos.</p></div>
<div class="paragraph"><p>Podemos incluso definir algunos y otros no, y hasta podemos duplicar valores</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">enum estado{
	SOLTERO=-3,
	CASADO=-4,
	VIUDO,// "-3", el compilador asigna el valor anterior, CASADO, + 1
	DIVORCIADO=3
};

estado dameEstado()
{
	return CASADO;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_clases_numeradas_enum_class_c_11">
<h2>clases numeradas (enum class) (C++11)</h2>
<div class="paragraph"><p>Trabajar con tipos enumerados puede aportar gran legibilidad a nuestro código, pero nos permite hacer cosas un poco curiosas, veamos el siguiente código:</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">enum estado{
	SOLTERO,
	CASADO,
	VIUDO,
	DIVORCIADO
};

enum sexo{
	HOMBRE,
	MUJER
};

int main()
{
	estado e=CASADO;
	sexo s=MUJER;
	if (s==e){ std::cout &lt;&lt; "son iguales" &lt;&lt; std::endl;}
	return 0;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Si hacemos la prueba, veremos que para nuestro programa, comparar <strong>sexo</strong> y <strong>estado</strong> es correcto, incluso nos dice que <strong>MUJER</strong> y <strong>CASADO</strong> son iguales.
Esto es porque ya hemos dicho que en realidad estamos tratando dos variables de tipo <strong>int</strong>.</p></div>
<div class="paragraph"><p>Para evitar este tipo de situaciones, podemos hacer uso de las <strong>clases enum</strong>. Si hacemos uso de esta novedad que aporta <strong>C++11</strong>, nuestros tipos <strong>enum</strong> estarán fuertemente tipados, y un control sobre su ámbito.</p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Vamos a repetir el caso haciendo uso del <strong>enum class</strong>, ahora NO va a permitir compilar el programa. Fijémonos también en que para acceder al valor <strong>CASADO</strong> ya no basta con ponerlo, hay que indicar mediante el <strong>Scope Resolution Operator</strong> a qué "clase" pertenece.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">enum class Estado {
	SOLTERO,
	CASADO,
	VIUDO,
	DIVORCIADO
};

enum class Sexo {
	HOMBRE,
	MUJER
};

int main()
{
	Estado e = Estado::CASADO;
	Sexo s = Sexo::MUJER;
	if (s == es) { std::cout &lt;&lt; "son iguales" &lt;&lt; std::endl; }
	return 0;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_estructuras_struct">
<h2>estructuras (struct)</h2>
<div class="paragraph"><p>Las estructuras son la aproximación que aportó el lenguaje <strong>C</strong> a la <strong>POO</strong>. Una estructura <strong>NO</strong> es tan potente como una clase, pero permite agrupar la información.
No se pueden definir funciones déntro de una estructura (bueno, existe un método mediante la definición de un puntero a una función&#8230;&#8203;), pero pueden ser muy cómodas para pasar varios argumentos agrupados como parámetros a una función.</p></div>
<div class="paragraph"><p>Veamos un ejemplo sencillo</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">struct Persona {
	int edad;
	char sexo;
};

int main()
{
	Persona p;
	p.edad=20;
	p.sexo='H';
	std::cout &lt;&lt; p.edad &lt;&lt; p.sexo &lt;&lt; std::endl;
	return 0;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Se pueden realizar inicializaciones mediante una <strong>initializer list</strong>, una lista donde aportamos los valores que queremos inicializar</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">struct Persona {
	int edad;
	char sexo;
};

int main()
{
	Persona p = {20, 'H'};
	std::cout &lt;&lt; p.edad &lt;&lt; p.sexo &lt;&lt; std::endl;
	return 0;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>En <strong>C++11</strong> se pueden definir valores automáticos para los miembros de una estructura (pero esto <strong>NO</strong> es compatible con el uso de una <strong>intializer list</strong>)</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">struct Persona {
	int edad = 20;
	char sexo = 'H';
};

int main()
{
	Persona p ;
	std::cout &lt;&lt; p.edad &lt;&lt; p.sexo &lt;&lt; std::endl;
	return 0;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_auto_c_11">
<h2>auto (C++11)</h2>
<div class="paragraph"><p>Previo a <strong>C++11</strong>, la palabra <strong>auto</strong> servía para especificar que una variable tenía duración automática (cosa que si no se especificaba de otra manera, así era).</p></div>
<div class="paragraph"><p>Ahora, <strong>auto</strong> es un tipo de dato que va a ser asignado por el compilador automáticamente.</p></div>
<div class="paragraph"><p>En <strong>C++14</strong> se amplió su uso para que también permitiese al compilador evaluar qué tipo devolvía una función</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">auto f() {
	auto x=3.1;
	return x;
}

int main()
{
	std::cout &lt;&lt; f() &lt;&lt; std::endl;
	return 0;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_4_bases_del_lenguaje_c_control_de_flujo">
<h2>4. Bases del lenguaje C++ (control de flujo)</h2>
<div class="olist arabic">
<ol class="arabic">
<li>
Control de flujo
</li>
<li>
Bloque if
</li>
<li>
Bloque switch
</li>
<li>
goto (NO USAR)
</li>
<li>
while y do while
</li>
<li>
for
</li>
<li>
break y continue
</li>
<li>
números aleatorioes en C++11
</li>
<li>
for each (C++11)
</li>
</ol>
</div>
</section>
<section class="slide" id="_control_de_flujo">
<h2>Control de flujo</h2>
<div class="paragraph"><p>En <strong>C++</strong>, el proceso comienza con la ejecución de la función <strong>main</strong>, y finaliza al llegar al final de la misma, al invocar un <strong>return</strong> desde la función main, o al llamar a la función <strong>exit</strong> de la <strong>std</strong>.</p></div>
<div class="paragraph"><p>Dentro del bloque <strong>main</strong>, podemos llamar a otras funciones o redirigir el proceso a unas u otras instrucciones en función de ciertos valores. Esto es lo que denominamos el <strong>control de flujo</strong></p></div>
<div class="paragraph"><p>En este tema, vamos a intentar conocer qué opciones nos aporta <strong>C++</strong>, si ya estáis familiarizados con otros lenguajes, veréis que la trasición va a ser bastante cómoda.</p></div>
</section>
<section class="slide" id="_bloque_if">
<h2>Bloque if</h2>
<div class="paragraph"><p>El bloque <strong>if</strong> permite condicionar la ejecución de un bloque de código en función al resultado de evaluar una expresión booleana. Puede tener ninguna, una o varias condiciones independientes para evaluar mediante <strong>else if</strong>, y un bloque a ejecutar si nada de lo anterior se cumple (<strong>else</strong>)</p></div>
<div class="paragraph"><p>Un ejemplo con if</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
	int n;
	std::cout &lt;&lt; "Escribe un número ";
	std::cin &gt;&gt; n;
	std::cout &lt;&lt; std::endl;
	if (n&lt;0){ std::cout &lt;&lt; "número negativo" ;}
	else if (n==0){ std::cout &lt;&lt; "número 0" ;}
	else if (n==1){ std::cout &lt;&lt; "número 1" ;}
	else { std::cout &lt;&lt; "número mayor que 1" ;}
	return 0;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_bloque_switch">
<h2>Bloque switch</h2>
<div class="paragraph"><p>El bloque <strong>switch</strong> permite elegir un comportamiento con respecto al valor de una expresión. Puede parecer similar a un bloque <strong>if</strong> com muchos <strong>else if</strong>, sin embargo tiene una diferencia muy importante. En cuanto se cumple la primera condición, el resto de bloques se van a ejecutar, salvo que usemos la palabra reservada <strong>break</strong>.</p></div>
<div class="paragraph"><p>Veamos un ejemplo</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
	int n;
	std::cout &lt;&lt; "Escribe un número ";
	std::cin &gt;&gt; n;
	std::cout &lt;&lt; std::endl;
	switch (n)
	{
		case 0:
		{
			std::cout &lt;&lt; "Es 0";
		}
		case 1:
		{
			std::cout &lt;&lt; "Es 1";
		}
		default:
		{
			std::cout &lt;&lt; "Es otro";
		}
	}
	return 0;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Entendamos cómo funciona este switch</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">switch (n)
	{
		case 0: //si n==0 entra, y también en todos los demás
		{
			std::cout &lt;&lt; "Es 0";
		}
		case 1: //si n==1 entraría aquí y en "default"
		{
			std::cout &lt;&lt; "Es 1";
		}
		default: //sólo entra si no es ni 1 ni 0
		{
			std::cout &lt;&lt; "Es otro";
		}
	}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Algo más habitual sería hacer eso</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">switch (n)
	{
		case 0: //si n==0 entra, y sale al final del bloque
		{
			std::cout &lt;&lt; "Es 0";
			break;
		}
		case 1: //si n==1 entraría aquí  y sale al final del bloque
		{
			std::cout &lt;&lt; "Es 1";
			break;
		}
		default: //sólo entra si no es ni 1 ni 0
		{
			std::cout &lt;&lt; "Es otro";
		}
	}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_goto_no_usar">
<h2>goto (NO USAR)</h2>
<div class="paragraph"><p>El <strong>goto</strong> permite saltar de la instrucción actual a la indicada por una etiqueta. Esta instrucción está considerada peligrosa, permite saltar a una posición arbitraria de código y tener un comportamiento peligroso o no esperado. Salvo que estéis intentando romper la seguridad de un sistema, no lo uséis.</p></div>
<div class="paragraph"><p>Vamos a mostrar un ejemplo de uso</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
goto fin;
std::cout&lt;&lt; "Hola" &lt;&lt; cout::endl; //este código no se ejecutará nunca
fin:
return 0;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_while_y_do_while">
<h2>while y do while</h2>
<div class="paragraph"><p>El bloque <strong>while</strong> nos permite repetir la ejecucion de un bloque de código hasta que se den las condiciones de salida especificadas en la declaración del mismo. Son especialmente útiles cuando no sabemos cuántas veces hay que repetir una tarea.</p></div>
<div class="paragraph"><p>Ejemplo de while</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
	int n=0;
	while (n&lt;10)
	{
		std::cout &lt;&lt; n++ &lt;&lt; std::endl;
	}
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>El bloque <strong>while</strong> puede no ejecutarse nunca, puesto que la condición de entrada/repetición puede no cumplirse. Existe una variante, en la que se asegura al menos una ejecución del bloque, el <strong>do while</strong>.</p></div>
<div class="paragraph"><p>En esta variante, la condición de repetición se especifica al final del bloque.</p></div>
<div class="paragraph"><p>Veamos el ejemplo</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
	int n=99;
	do
	{
		std::cout &lt;&lt; n++ &lt;&lt; std::endl;
	} while (n &lt; 10);
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_for">
<h2>for</h2>
<div class="paragraph"><p>Si queremos repetir una serie de veces controlada un bloque, la mejor opción es usar el <strong>for</strong>. A la instrucción <strong>for</strong> se le pasan por un lado las declaraciones/inicializaciones de variables, las condiciones de repetición y el post-incremento, todas ellas separadas por <strong>;</strong>. Cualquiera de estas instrucciones pueden no declararse</p></div>
<div class="paragraph"><p>Bucle for</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
	for (int i=0; i&lt;10; i++)
	{
		std::cout &lt;&lt; i &lt;&lt; std::endl;
	}
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Pero ya hemos dicho antes que no tienen por qué contener instrucciones ninguna de las tres opciones del <strong>for</strong></p></div>
<div class="paragraph"><p>Bucle for sin declarar la variable</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
	int i=0;
	for (; i&lt;10; i++)
	{
		std::cout &lt;&lt; i &lt;&lt; std::endl;
	}
}</code></pre>
</div>
</div>
<div class="paragraph"><p>Bucle for infinito</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
	int i=0;
	for (;; i++)
	{
		std::cout &lt;&lt; i &lt;&lt; std::endl;
	}
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_break_y_continue">
<h2>break y continue</h2>
<div class="paragraph"><p>Podemos interactuar con los flujos definidos por los bloques de control mediante las instrucciones <strong>break</strong> y <strong>continue</strong></p></div>
<div class="ulist">
<ul>
<li><strong>break</strong> fuerza la finalización de un bloque de control, así nos sacaría de un <strong>while</strong> o de un <strong>for</strong>, sin esperar a que se cumplan las condiciones de finalización</li>
<li><strong>continue</strong> finaliza la iteración actual del bloque, pero no el bloque en si. Continuaría con la siguiente iteración</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
	for (int i=0; i&lt;10; i++)
	{
		if (i==5) {continue;}
		if (i==7) {break;}
		std::cout &lt;&lt; i &lt;&lt; std::endl;
	}
}</code></pre>
</div>
</div>
<div class="paragraph"><p>esto mostrará por pantalla 0,1,2,3,4,6</p></div>
</section>
<section class="slide" id="_números_aleatorioes_en_c_11">
<h2>números aleatorioes en C++11</h2>
<div class="paragraph"><p>La generación de números aleatorios siempre ha sido un problema en los lenguajes de programación.
Hasta la aparición de <strong>C++11</strong>, se delegaba la gestión de números pseudo-aleatorios a la función <strong>rand</strong>. Esto, generaba siempre los mismos números para una misma inicialización, por lo que se intentaba realizar la inicialización mediante un número obtenido por ejemplo del reloj del sistema llamando a <strong>srand</strong>.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;

int main()
{
    srand(static_cast&lt;unsigned int&gt;(time(0)));

    for (int i=0; i &lt; 10; ++i)
    {
        std::cout &lt;&lt; rand() &lt;&lt; "\t";
	}
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>En <strong>C++11</strong> se ha mejorado drásticamente la obtención de números aleatorios. Por un lado, permite usar una fuente hardware para obtener valores con los que inicializar nuestro generador con <strong>radom_device</strong>, por otro, permite usar otros algoritmos de generacion (como <strong>mersenne twister</strong>)</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;iostream&gt;
#include &lt;random&gt;

int main()
{
	std::random_device rd;
	std::mt19937 mersenne(rd());
	for (int count = 0; count &lt; 12; ++count)
	{
		std::cout &lt;&lt; mersenne() &lt;&lt; "\t";
	}
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_for_each_c_11">
<h2>for each (C++11)</h2>
<div class="paragraph"><p>En <strong>C++11</strong> se introduce un nuevo tipo de <strong>bloque for</strong>, como el que ya existe en <strong>java</strong> o en <strong>python</strong>. Un <strong>for</strong> que nos permite iterar cómodamente sobre un <strong>array</strong>. Esto nos proporciona un acceso más cómodo y seguro a los elementos del <strong>array</strong>.</p></div>
<div class="paragraph"><p>Aunque veremos más adelant cómo funcionan los arrays, veamos un ejemplo de un bucle <strong>for each</strong>.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;iostream&gt;

int main()
{
	int array[] = {3,7,2,4,9,4,12};
	for (int i:array)
	{
		std::cout &lt;&lt; i &lt;&lt; std::endl;
	}
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_5_prácticas_i">
<h2>5. Prácticas I</h2>
<div class="olist arabic">
<ol class="arabic">
<li>
Ejercicios
</li>
</ol>
</div>
</section>
<section class="slide" id="_ejercicios">
<h2>Ejercicios</h2>
<div class="ulist">
<ul>
<li>Lee un número por teclado e indica si es divisible entre 2 (resto = 0). Si no lo es, también debemos indicarlo.</li>
<li>Codificar un programa que recibiendo un número por teclado devuelva si es primo o no.</li>
<li>Haz un programa que pida un número por pantalla. Posteriormente pida números hasta que se ponga el mismo número que se introdujo al principio. Si es distinto, ha de decir si el número escrito es mayor o menor</li>
</ul>
</div>
</section>
<section class="slide" id="_6_arrays_y_punteros">
<h2>6. Arrays y punteros</h2>
<div class="olist arabic">
<ol class="arabic">
<li>
Arrays
</li>
<li>
swap (movido en C++11)
</li>
<li>
Arrays multidimensionales
</li>
<li>
Punteros
</li>
<li>
Memoria dinámica, new y delete
</li>
<li>
Variables de referencia
</li>
<li>
Acceso a los atributos y métodos
</li>
<li>
Puntero void
</li>
</ol>
</div>
</section>
<section class="slide" id="_arrays">
<h2>Arrays</h2>
<div class="paragraph"><p>Un <strong>array</strong> es la colección más elemental del lenguaje <strong>C++</strong>. Es un conjunto de elementos accesibles a través de un único nombre de variable.</p></div>
<div class="paragraph"><p>Un <strong>array</strong> se puede hacer con cualquier tipo de datos, pero su tamaño es fijo, se tiene que especificar al declarar la variable. Es decir, no podemos crear un <strong>array</strong> de un tamaño obtenido en tiempo de compilación.</p></div>
<div class="paragraph"><p>Para trabajar con un <strong>array</strong> hacemos uso de <strong>[</strong> y <strong>]</strong>, y si queremos conocer sus elementos podemos hacer uso del <strong>sizeof</strong> (posteriormente dividiremos por el tamaño de 1 elemento)</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int array1[5];
int array2[]={1,2,3};
array1[1]=4;</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Aunque se puede pasar un <strong>array</strong> como argumento a una función, hay que tener cuidado, ya que en <strong>C++</strong> se hace una copia de los elementos recibidos como parámetro, sin embargo al pasar un <strong>array</strong> se va a comportar como si pasamos un puntero, es decir, cualquier cambio sobre el <strong>array</strong> en la función se conservará. Además, el uso de <strong>sizeof</strong> dentro de la función <strong>NO</strong> va a devolver el tamaño real.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">void f(int array[])
{
	std::cout &lt;&lt; sizeof(array) &lt;&lt; std::endl;
}

int main()
{
	int array[]={1,2,3,4,5};
	std::cout &lt;&lt; sizeof(array) &lt;&lt; std::endl;
	f(array);

}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Es importante resaltar también que en <strong>C</strong>, las cadenas de texto eran <strong>arrays</strong> de caracteres, finalizados con el caracter especial <strong>\n</strong>. En <strong>C++</strong> vamos a intentar hacer uso de las cadenas como se hacían en <strong>C</strong>, y siempre que podamos vamos a usar las cadenas <strong>std::string</strong>, que son más seguras y cómodos de usar.</p></div>
</section>
<section class="slide" id="_swap_movido_en_c_11">
<h2>swap (movido en C++11)</h2>
<div class="paragraph"><p><strong>C++</strong> aporta una un método llamado <strong>swap</strong> para permutar el valor de dos elementos dados. Esto suele ser de gran utilidad a la hora de realizar por ejemplo, una ordenación sobre un <strong>array</strong>. En versiones anteriores a <strong>C++1</strong> encontrábamos este método en la librería <strong>algorithm</strong>, pero se ha movido a <strong>utility</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">void f(int array[])
{
	std::cout &lt;&lt; sizeof(array) &lt;&lt; std::endl;
}

int main()
{
    int x = 27;
    int y = 32;
    std::cout &lt;&lt; "antes swap: x = " &lt;&lt; x &lt;&lt; ", y = " &lt;&lt; y &lt;&lt; '\n';
    std::swap(x, y);
    std::cout &lt;&lt; "despues swap:  x = " &lt;&lt; x &lt;&lt; ", y = " &lt;&lt; y &lt;&lt; '\n';
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_arrays_multidimensionales">
<h2>Arrays multidimensionales</h2>
<div class="paragraph"><p>Ya vimos anteriormente que un <strong>array</strong> podía estar hecho con cualquier tipo de elemento, incluso otro <strong>array</strong>. Esto es a lo que llamamos un <strong>array multidimensional</strong>.</p></div>
<div class="paragraph"><p>No es muy habitual hacer <strong>arrays</strong> de más de 2 dimensiones, pero pueden crearse de la misma manera que vamos a crear ahora un <strong>array</strong> bidimensional.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
	int array_2n[2][2];
	array_2n[0][0]=0;
	array_2n[0][1]=1;
	array_2n[1][0]=2;
	array_2n[1][1]=3;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_punteros">
<h2>Punteros</h2>
<div class="paragraph"><p>Una variable almacena el valor del dato con el que definió. Así pues una variable de tipo <strong>int</strong> guardará un entero, y una variable tipo <strong>char</strong> guardará un caracter. Vimos en <strong>Operadores</strong> que distintos datos ocupaban distintas áreas de memoria.</p></div>
<div class="paragraph"><p>Ahora bien, en ocasiones nos interesa guardar en una variable no el objeto en si, si no una <strong>referencia</strong> al mismo. Un <strong>puntero</strong> es una variable que en lugar de tener un valor con sentido propio, almacena la posición en memoria de un objeto.</p></div>
<div class="paragraph"><p>En <strong>C++</strong>, al contrario que en otros lenguajes, cualquier tipo de dato puede ser definido como <strong>estático</strong> (su valor se almacena en la variable) o <strong>dinámico</strong> (se almacena la dirección de memoria a dicho objeto)</p></div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="6 Pointer" src="images/pics/6-Pointer.png">
</div>
<div class="title">Figure 12. Diferencia entre puntero y valor</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Ya sabemos definir variables, indicamos su <strong>tipo</strong> y luego su <strong>nombre</strong>, pero para usar variables tipo <strong>puntero</strong> hay que añadir detrás del tipo el caracter <strong>*</strong>. Esto le dice al compilador que dicha variable va a contener una referencia a un objeto (y no el objeto en si).</p></div>
<div class="paragraph"><p>Podemos obtener la dirección de una objeto mediante el caracter <strong>&</strong>, y obtener el valor apuntado por un <strong>puntero</strong> mediante el caracter <strong>*</strong>.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
	int x = 5;
	int* ptr_x = &amp;x;
	int z = *ptr_x;
	std::cout &lt;&lt; x &lt;&lt; '\t' &lt;&lt; ptr_x &lt;&lt; '\t' &lt;&lt; z &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Cuando creamos punteros, tenemos que tener en cuenta el valor que se debe asignar a un <strong>puntero</strong> cuando no tiene ningún valor. Para ello usamos la palabra reservada <strong>NULL</strong>. Esta macro equivale a la dirección <strong>0</strong> de memoria, que por convenio se entiende que hace referencia al puntero <strong>nulo</strong>.</p></div>
<div class="paragraph"><p>No es especialmente elegante inicializar un <strong>puntero</strong> a <strong>0</strong> (Recordemos que <strong>NULL</strong> es un macro a <strong>0</strong>), y el compilador no distingue si nos referimos al <strong>int</strong> o a la dirección <strong>nula</strong>.</p></div>
<div class="paragraph"><p>En <strong>C++11</strong> se introdujo el literal <strong>nullptr</strong>, que crea un <strong>puntero</strong> vacío. Este literal, en realidad crea un <strong>puntero</strong> de tipo <strong>int</strong> apuntando a <strong>0</strong>, por lo que es más seguro que usar <strong>0</strong> directamente o la macro <strong>NULL</strong>.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
	int* ptr_x = NULL;
	int* ptr_y = nullptr;
	std::cout &lt;&lt; ptr_x &lt;&lt; '\t' &lt;&lt; ptr_y &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Cuando trabajamos con <strong>array</strong> como parámetros de una función, estamos trabajando de manera similar a si trabajaramos con un <strong>puntero</strong>.</p></div>
<div class="paragraph"><p>Esto, queda mas claro con el ejemplo que mostramos</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">void f(int* a){
	std::cout &lt;&lt; a[0] &lt;&lt; '\t' &lt;&lt; a[1] &lt;&lt; std::endl;
}
void f2(int a[]){
	std::cout &lt;&lt; a[0] &lt;&lt; '\t' &lt;&lt; a[1] &lt;&lt; std::endl;
}
int main()
{
	int array[] = { 2,5,7 };
	int* ptr_x = array;
	f(array);
	f2(ptr_x);
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Los <strong>punteros</strong> pueden ser muy peligrosos en <strong>C++</strong>, porque se pueden manipular directamente direcciones de memoria.</p></div>
<div class="paragraph"><p>Yo puedo trabajar con un <strong>puntero</strong> como si fuera un entero en realidad, y desplazarme por la memoria de la máquina sumando un número a dicha posición.</p></div>
<div class="paragraph"><p>El siguiente ejemplo imprimirá el 9 por pantalla</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
	int array[] = { 4,7,9,0 };
	int* ptr_x = array;
	ptr_x += 2;
	std::cout &lt;&lt; *(ptr_x) &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_memoria_dinámica_new_y_delete">
<h2>Memoria dinámica, new y delete</h2>
<div class="paragraph"><p>En <strong>C++</strong> existen tres tipos de asignaciones de memoria:</p></div>
<div class="ulist">
<ul>
<li><strong>Asignación estática</strong>: Memoria que se reserva al ejecutar el programa y que persiste durante su ejecución</li>
<li><strong>Asignación automática</strong>: Memoria que se reserva al ejecutar el bloque donde se declara, y liberada tras su finalización. Las variables locales y los parámetros de función usan esta asignación.</li>
<li><strong>Asignación dinámica</strong>: La asignación se realiza por parte del programador, y persiste en memoria hasta que se decide eliminar.</li>
</ul>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Para realizar una <strong>reserva dinámica</strong> de memoria, necesitamos declarar un <strong>puntero</strong>. Este puntero será el encargado de apuntar al objeto que vamos a crear.</p></div>
<div class="paragraph"><p>Para crear una instancia de dicho objeto, usaremos la instrucción <strong>new</strong>, seguido de la llamada al <strong>constructor</strong> de la <strong>clase</strong> que queramos instanciar.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
	int* ptr_x = new int();
	// también vale "new int;", que llamará al constructor sin parámetros
	*ptr_x = 9;
	std::cout &lt;&lt; *(ptr_x) &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Al contrario que en <strong>java</strong> con su recolector de basura, en <strong>C++</strong> la gestión de la memoria dinámica está en manos del programador, que es quien debe decidir si la memoria referenciada debe ser liberada o no.</p></div>
<div class="paragraph"><p>Perder todas las referencias a un área de memoria usada supone un <strong>memory leak</strong> y es uno de los mayores problemas que se suelen presentar en <strong>C++</strong>.</p></div>
<div class="paragraph"><p>Para liberar memoria, basta con hacer uso de <strong>delete</strong>, que invocará al <strong>destructor</strong> de dicha clase para tal fin.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
	int* ptr_x = new int();
	// también vale "new int;", que llamará al constructor sin parámetros
	*ptr_x = 9;
	std::cout &lt;&lt; *(ptr_x) &lt;&lt; std::endl;
	delete ptr_x;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>En <strong>C++11</strong> se introdujo una recolección automática de basura, mediante el uso de <strong>shared_ptr</strong> (incluído en la cabecera <strong> <memory></strong>). Los punteros declarados de esta manera gestionan su limpieza (lleva la cuenta de cuántos punteros hay al objeto, cuando desaparece un puntero, se resta), aunque siempre puede haber problemas de referenciación cruzada.</p></div>
<div class="paragraph"><p>Para instanciar el objeto, debemos hacer uso de <strong>make_shared</strong>, en la cabecera <strong><mutex></strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;mutex&gt;

class Test
{
public:
	int x;
	Test() { x = 99; std::cout &lt;&lt; "  Test::Test()\n"; }
	~Test() { std::cout &lt;&lt; "  Test::~Test()\n"; }
};

int main()
{
	std::shared_ptr&lt;Test&gt; ptr_sh= std::make_shared&lt;Test&gt;();
	std::cout &lt;&lt; ptr_sh-&gt;x &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Adicionalmente existen otros dos punteros, <strong>auto_ptr</strong> y su sucesor <strong>unique_ptr</strong>, que permiten una gestión también automática de un objeto, pero no permiten tener más de un puntero que apunte a dicho objeto</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;memory&gt;
class A {};
int main()
{
	std::unique_ptr&lt;A&gt; a(new A());
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>También se puede usar la <strong>memoria dinámica</strong> para crear <strong>arrays</strong> cuyo tamaño elegimos en tiempo de ejecución. Para ello usaremos la instrucción <strong>new[]</strong>, y al contrario que con los <strong>arrays estáticos</strong>, vamos a tener que encargarnos de liberar la memoria, con la instrucción <strong>delete[]</strong>.</p></div>
<div class="paragraph"><p>Veamos un ejemplo</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
	int* array;
	array = new int[2];
	array[0] = 8;
	array[1] = 2;
	std::cout &lt;&lt; array[0] &lt;&lt; array[1] &lt;&lt; std::endl;
	delete[] array;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>En <strong>C+11</strong> se introdujo además la posibilidad de inicializar los <strong>arrays</strong> creados dinámicamente mediante <strong>listas inicializadoras</strong>, con lo que el siguiente código sólo es válido a partir de tal versión.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
	int* array;
	array = new int[2] {8,2};
	std::cout &lt;&lt; array[0] &lt;&lt; array[1] &lt;&lt; std::endl;
	delete[] array;
}</code></pre>
</div>
</div>
<div class="paragraph"><p>Por consistencia, también se permite crear <strong>arrays estáticos</strong> de manera análoga, <strong>int array[2] {8,2};</strong></p></div>
</section>
<section class="slide" id="_variables_de_referencia">
<h2>Variables de referencia</h2>
<div class="paragraph"><p>Una <strong>referencia</strong> es un tipo de variable que actúa como <strong>alias</strong> de otra variable ya declarada. Cuando declaramos una variable como <strong>referencia</strong>, hacemos uso del caracter <strong>&</strong>. Recordemos que este caracter también se usa para obtener la dirección de una variable ya declarada.</p></div>
<div class="paragraph"><p>Lo mejor es verlo con un ejemplo</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
	int x=9;
	int &amp;y=x;
	y=3;
	std::cout &lt;&lt; x &lt;&lt; y &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
<div class="paragraph"><p>Aunque hayamos declarado 2 variables, en realidad sólo tenemos 1, ya que <strong>y</strong> actúa como alias de <strong>x</strong></p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Una de las utilidades de las <strong>referencias</strong>, es el hecho de poder pasar parámetros a una función y que esta pueda modificar su valor</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">void f(int &amp;ref, int noref)
{
	noref = 6;
	ref = 6;
}
int main()
{
	int n1 = 5;
	int n2 = 5;
	std::cout &lt;&lt; n1 &lt;&lt; n2 &lt;&lt; '\n';
	f(n1, n2);
	std::cout &lt;&lt; n1 &lt;&lt; n2 &lt;&lt; '\n';
	return 0;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Incluso rizando el rizo, podemos llegar a usar una <strong>función</strong> en el lado izquierdo de una asignación, devolviendo una <strong>referencia</strong> a una variable.</p></div>
<div class="paragraph"><p>En este ejemplo queremos alterar el valor del mayor de dos números</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int&amp; f(int &amp;x, int &amp;y)
{
	if (x&gt;y)
		return x;
	return y;
}

int main()
{
	int n1 = 1;
	int n2 = 4;
	std::cout &lt;&lt; n1 &lt;&lt; n2 &lt;&lt; '\n';
	f(n1, n2)=5;
	std::cout &lt;&lt; n1 &lt;&lt; n2 &lt;&lt; '\n';
	return 0;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_acceso_a_los_atributos_y_métodos">
<h2>Acceso a los atributos y métodos</h2>
<div class="paragraph"><p>Aunque todavía no hemos visto las <strong>clases</strong> en <strong>C++</strong>, vamos a explicar cómo acceder a sus <strong>atributos</strong> y <strong>métodos</strong>.</p></div>
<div class="ulist">
<ul>
<li>Si la variable es del tipo de la clase, usaremos el operador <strong>.</strong> para acceder al atributo o método</li>
<li>Si la variable es un <strong>puntero</strong> a la clase, usaremos el operador <strong>-></strong> para acceder a sus atributos o métodos.</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class algo{
public:
	int x;
	algo(int x) { this-&gt;x = x; }
	void f() { std::cout &lt;&lt; "algo" &lt;&lt; std::endl; }
};

int main()
{
	algo a(0);
	algo* b = new algo(1);
	std::cout &lt;&lt; a.x &lt;&lt; b-&gt;x &lt;&lt; std::endl;
	a.f();
	b-&gt;f();
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_puntero_void">
<h2>Puntero void</h2>
<div class="paragraph"><p>El puntero <strong>void</strong> es un tipo especial de <strong>puntero</strong> que puede ser usado para apuntar a cualquier tipo de objeto (algo parecido a los punteros <strong>Object</strong> en <strong>java</strong>).
Al no saber qué tipo de objeto apunta, no puede ser desreferenciado sin antes realizar un <strong>casting</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
	int x = 5;
	void *ptr_void = &amp;x;
	int *ptr_int = static_cast&lt;int*&gt;(ptr_void);
	std::cout &lt;&lt; *ptr_int &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_7_prácticas_ii">
<h2>7. Prácticas II</h2>
<div class="olist arabic">
<ol class="arabic">
<li>
Ejercicios
</li>
</ol>
</div>
</section>
<section class="slide" id="_ejercicios_2">
<h2>Ejercicios</h2>
<div class="ulist">
<ul>
<li>Realiza una aplicación que pida por pantalla números, hasta que el usuario escriba 0, almacénalos en un array y luego recorre el array mostrándolos todos por pantalla.</li>
</ul>
</div>
</section>
<section class="slide" id="_8_programación_orientada_a_objetos">
<h2>8. Programación Orientada a Objetos</h2>
<div class="olist arabic">
<ol class="arabic">
<li>
Funciones
</li>
<li>
Funciones inline
</li>
<li>
Sobrecarga de funciones
</li>
<li>
La función main
</li>
<li>
La Programación Orientada a Objetos
</li>
<li>
La Clase en C++
</li>
<li>
Visibilidad
</li>
<li>
El puntero this
</li>
<li>
Cabecera (.h) y código (.cpp) de una clase
</li>
<li>
Objetos const
</li>
<li>
Atributos y métodos static
</li>
<li>
Funciones y clases friend
</li>
</ol>
</div>
</section>
<section class="slide" id="_funciones">
<h2>Funciones</h2>
<div class="paragraph"><p>En <strong>pass[C++]</strong> una <strong>función</strong> consta de <strong>declaración</strong> y <strong>cuerpo</strong>.</p></div>
<div class="ulist">
<ul>
<li>En el <strong>cuerpo</strong> de la <strong>función</strong> incluímos, como <strong>bloque</strong> todas las instrucciones que queremos realice.</li>
<li>En la <strong>declaración</strong>, indicamos qué tipo de <strong>elemento</strong> va a devolver la <strong>función</strong> y los tipos de <strong>elementos</strong> que va a recibir como <strong>parámetros</strong></li>
</ul>
</div>
<div class="paragraph"><p>Un ejemplo sencillo de función</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int f(int param1)
{
	param1++;
	return param1;
}
int main()
{
	int x=0;
	std::cout &lt;&lt; f(x) &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Un punto a tener en cuenta es que los <strong>parámetros</strong> pasados a la <strong>función</strong> van a ser copiados, es decir, cualquier cambio realizado sobre dicha variable se va a perder al finalizar la función.</p></div>
<div class="paragraph"><p>Podemos alterar este comportamiento si indicamos en la <strong>declaración</strong> que vamos a recibir parámetros como referencia, con el caracter <strong>&</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">void f1(int param1){
	param1++;
}
void f2(int&amp; param1){
	param1++;
}
int main()
{
	int x=0;
	std::cout &lt;&lt; x &lt;&lt; std::endl;
	f1(x);
	std::cout &lt;&lt; x &lt;&lt; std::endl;
		f2(x);
	std::cout &lt;&lt; x &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Existe una tercera forma de pasar <strong>argumentos</strong> a nuestra <strong>función</strong>, pasando sus direcciones. En este caso la <strong>función</strong> espera recibir un <strong>puntero</strong>, va a hacer una copia de la <strong>variable</strong> que almacena la dirección del <strong>objeto apuntado</strong>, por lo que si decidimos que apunte a otro, este cambio <strong>NO</strong> se va a conservar.
Sin embargo, podemos alterar cualquier <strong>atributo</strong> del objeto que está siendo apuntado.
En el siguiente ejemplo veremos impreso <strong>991</strong>, ni <strong>01</strong>, ni <strong>9999</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class Test {
public:
	int x;
};
void f(Test* t1, Test* t2) {
	t1-&gt;x = 99;
	t2 = t1;
}
int main()
{
	Test* t1 = new Test();
	t1-&gt;x = 0;
	Test* t2 = new Test();
	t2-&gt;x = 1;
	f(t1, t2);
	std::cout &lt;&lt; t1-&gt;x &lt;&lt; t2-&gt;x &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Análogamente, al igual que podemos <strong>recibir</strong> parámetros tanto por <strong>referencia</strong>, por <strong>valor</strong> o por <strong>dirección</strong>, podemos <strong>devolver</strong> un dato de las mismas maneras</p></div>
<div class="ulist">
<ul>
<li>Al devolver por <strong>valor</strong>, estamos devolviendo el valor de una variable u operación</li>
<li>Al devolver una <strong>dirección</strong>, tenemos que almacenar dicha dirección en un <strong>puntero</strong>, para poder trabajar con ella directamente</li>
<li>Devolviendo un dato por <strong>referencia</strong> (con el símbolo <strong>&</strong>), estamos devolviendo la variable en si, con lo que podemos trabajar diréctamente con ellas</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">Tipo f(){...};
Tipo* f(){...};
Tipo&amp; f(){...};</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>A una <strong>función</strong> también podemos darle unos <strong>parámetros por defecto</strong>. Si la función no es llamada con todos sus <strong>parámetros</strong>, sustituirá los valores no facilitados por los especificados en su declaración.
Hacer esto es sencillo, en la declaración, por cada <strong>parámetro</strong> para el que queramos dar un valor <strong>por defecto</strong>, añadimos después de dicho parámetro, el símbolo <strong>=</strong> y el valor que queramos asignar.</p></div>
<div class="paragraph"><p>Existe no obstante una restricción, si declaramos un <strong>parámetro</strong> con un valor por defecto, cualquier otro parámetro que le suceda en la declaración, ha de contener también un <strong>valor por defecto</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">void f(int x=99){
	std::cout &lt;&lt; x &lt;&lt; std::endl;
}
int main()
{
	f();
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Por último, en ocasiones es interasnte evitar que se cometa el error de intentar alterar el valor de un <strong>parámetro</strong> recibido en una <strong>función</strong>.</p></div>
<div class="paragraph"><p>Para evitar esto, podemos definir los parámetros de la funcion como <strong>const</strong>, así cualquier intento de alterar dicho <strong>parámetro</strong> resulta en un error de compilación.</p></div>
<div class="paragraph"><p>El código dará error de compilación</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">void f(const int x)
{
	x = 4;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_funciones_inline">
<h2>Funciones inline</h2>
<div class="paragraph"><p>El uso de funciones tiene muchas ventajas, reutilización de código, facilidad de mantenimiento&#8230;&#8203; pero la invocación a una <strong>función</strong> es relativamente costosa, se crea una pila nueva en la llamada, se salta a una zona de memoria distinta, se hacen copia de los parámetros&#8230;&#8203;</p></div>
<div class="paragraph"><p>En muchas ocasiones, las funciones son muy grandes, y el impacto de su llamada es muy pequeño con respecto al total del tiempo consumido dentro de la <strong>función</strong>, pero si hablamos de <strong>funciones pequeñas</strong>, veremos que el consumo relativo que se gasta en dicha llamada es bastante alto.</p></div>
<div class="paragraph"><p>Para solucionar esto, en <strong>C++</strong> existe la palabra reservada <strong>inline</strong>. Cuando se declara una <strong>función</strong> como <strong>inline</strong>, el compilador sustituirá cualquier llamada a dicha función por el <strong>código</strong> interno de la misma, es decir, <strong>expande</strong> la función <strong>in situ</strong>.</p></div>
<div class="paragraph"><p>Esto, evidentemente, hace aumentar el tamaño de nuestro programa final, pero otorga importantes mejoras de rendimiento. Lo ideal, es buscar un <strong>equilibrio</strong>, por lo que las funciones <strong>pequeñas</strong> suelen ser declaradas <strong>inline</strong>, mientras que las <strong>grandes</strong> no.</p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Vamos a ver un ejemplo de declaración de una <strong>función inline</strong>. (Cabe añadir que implementar una función diréctamente en el fichero <strong>header</strong>, la convierte automáticamente en <strong>función inline</strong>).</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">inline int min(int x, int y)
{
    return x &gt; y ? y : x;
}

int main()
{
    std::cout &lt;&lt; min(5,6) &lt;&lt; std::endl;
    return 0;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Vamos a añadir algo de información que no vamos a ver en detalle, pero que es interesante saber que existe.</p></div>
<div class="paragraph"><p>En <strong>C++</strong> se pueden declarar <strong>punteros</strong> a <strong>funciones</strong>, la declaración de dicho puntero sería como sigue:</p></div>
<div class="paragraph"><p><strong>tipo (*nombre_puntero)(tipo_param1,tipo_param2...)</strong></p></div>
<div class="paragraph"><p>Para asignar una <strong>función</strong> a un <strong>puntero a funciones</strong>, podemos usar el operador de asignación <strong>=</strong>, seguido del nombre de la función a la que queremos apuntar</p></div>
<div class="paragraph"><p>Por último, para llamar a la <strong>función</strong> apuntada, primero tenemos que <strong>desreferenciar</strong> dicho <strong>puntero</strong> mediante el operador <strong>*</strong></p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Un ejemplo de uso de <strong>punteros a funciones</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int max(int x, int y) {
	return (x &gt; y ? x : y);
}
int main()
{
	int (*puntero_f)(int, int);
	puntero_f = max;
	std::cout &lt;&lt; (*puntero_f)(3, 4) &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_sobrecarga_de_funciones">
<h2>Sobrecarga de funciones</h2>
<div class="paragraph"><p>La <strong>sobrecarga</strong> de <strong>funciones</strong> hace referencia a la posibilidad de crear más de una <strong>función</strong> con un mismo nombre, siempre y cuando la cantidad o el tipo de los <strong>parámetros</strong> cambie.</p></div>
<div class="paragraph"><p>Un ejemplo de sobrecarga de funciones</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">void f(int x){
	std::cout&lt;&lt; "Es int" &lt;&lt; std::endl;
}
void f(float x){
	std::cout&lt;&lt; "Es float" &lt;&lt; std::endl;
}
int main()
{
    int x=9;
	float z=39;
	f(z);
	f(x);
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_la_función_main">
<h2>La función main</h2>
<div class="paragraph"><p>La función <strong>main</strong> puede recibir <strong>parámetros</strong> pasados por el <strong>usuario</strong> a través de línea de comandos. Para ello, recibe dos parámetros <strong>argc</strong> y <strong>argv</strong>.</p></div>
<div class="ulist">
<ul>
<li><strong>argc</strong> es un <strong>int</strong> que contiene el total de argumentos que ha recibido nuestro proceso (mínimo 1, el nombre del proceso)</li>
<li><strong>argv</strong> es un <strong>array de punteros a caracteres</strong>, o lo que es lo mismo, cada uno de los argumentos recibidos (en forma de <strong>char*</strong>)</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main(int argc, char *argv[])
{
	std::cout &lt;&lt; "imprimimos los argumentos" &lt;&lt; std::endl;
    for (int nArg=0; nArg &lt; argc; nArg++)
        std::cout &lt;&lt; nArg &lt;&lt; " " &lt;&lt; argv[nArg] &lt;&lt; std::endl;
    return 0;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_la_programación_orientada_a_objetos">
<h2>La Programación Orientada a Objetos</h2>
<div class="paragraph"><p>Hasta ahora, todo lo que hemos visto eran las bases de la programacion en <strong>C++</strong>, pero ahora podemos dar un paso adelante, y empezar a entender qué significa la <strong>Programación Orientada a Objetos</strong>.</p></div>
<div class="paragraph"><p>Un programa no es más que un conjunto de instrucciones que se ejecutan en un computador, y que trabajan con una información almacenada en su memoria. Si bien, podemos realizar cualquier tarea de esta manera, el mantenimiento de dicho programa puede ser tremendamente complejo.</p></div>
<div class="paragraph"><p>Como en todo, ha habido una evolución. En primer lugar se tuvieron programas monolíticos, con todo lo que se necesitaba realizar. A medida que los programas se volvieron más complejos, esto fue cambiando y empezaron a dividirse las tareas, hacer uso de más funciones, etc. No obstante, las funciones y los datos no tenían una relación directa entre si, con lo que nuestros programas no realizaban una representación fiel de la realidad.</p></div>
<div class="paragraph"><p>El siguiente paso, la <strong>POO</strong>, consiste en la creación de <strong>objetos</strong> que disponen tanto de <strong>datos</strong> o <strong>atributos</strong> como de sus propias <strong>funciones</strong> o <strong>métodos</strong>, todos unidos bajo una misma <strong>clase</strong>. Esto nos permite realizar un modelado del mundo mucho más intuitivo, y permite interactuar entre los distintos objetos de nuestro mundo</p></div>
</section>
<section class="slide" id="_la_clase_en_c">
<h2>La Clase en C++</h2>
<div class="paragraph"><p>La clase en <strong>C++</strong> consta de <strong>atributos</strong> y <strong>métodos</strong>. Sobre cada elemento se aplican unos criterios de <strong>visibilidad</strong> que estudiaremos en detalle más adelante.</p></div>
<div class="paragraph"><p>Es decir, grosso modo, una <strong>clase</strong> es un conjunto de <strong>variables</strong> y <strong>funciones</strong> agrupadas bajo un mismo techo.</p></div>
<div class="paragraph"><p>Para definir una clase, necesitamos usar la palabra reservada <strong>class</strong>, y su definición es similar a la de una <strong>estructura</strong>, pero pudiendo añadir <strong>funciones</strong>.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class PrimeraClase
{
	int x;
	int getX(){return x;}
};</code></pre>
</div>
</div>
<div class="paragraph"><p>Recordemos que las <strong>clases</strong> al igual que las <strong>estructuras</strong> deben acabar con <strong>;</strong></p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Podemos crear <strong>instancias</strong> de dicha clase, tanto <strong>locales</strong> como <strong>dinámicas</strong>. Las instancias <strong>locales</strong> se crean al declarar la variable del tipo de la <strong>clase</strong>, mientras que las instancias <strong>dinámicas</strong> necesitan que el programador incluya una solicitud de creación mediante la instrucción <strong>new</strong>.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class PrimeraClase
{
	int x;
};
int main()
{
	PrimeraClase local();
	PrimeraClase* dinamica=new PrimeraClase();
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Definir una <strong>método</strong> dentro de una <strong>clase</strong> es análogo a definir una <strong>función</strong>, con la salvedad de que realizamos dicha definición dentro del <strong>bloque</strong> de la <strong>clase</strong>.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class PrimeraClase
{
	int x;
	int getX(){return x;}
};
int main()
{
	PrimeraClase local();
	PrimeraClase* dinamica=new PrimeraClase();
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Al invocar a <strong>new</strong>, <strong>C++</strong> crea una instancia de la clase, invocando a su <strong>constructor</strong>. Un <strong>constructor</strong> es un método de la clase que inicializa los atributos de la instancia. Si no hay un constructor definido, el compilador creará uno por defecto.</p></div>
<div class="paragraph"><p>Para crear un <strong>constructor</strong>, hay que crear un método que <strong>NO</strong> devuelva ningún tipo de dato (ni si quiera <strong>void</strong>), y este método se debe llamar tal y como se llame la clase.</p></div>
<div class="paragraph"><p>Puede haber tantos <strong>constructores</strong> como se quiera, con los <strong>parámetros</strong> que consideremos. <strong>C++</strong> va a llamar al constructor que corresponda en el momento de la <strong>instanciación</strong> del objeto.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class PrimeraClase
{
public:
	int x;
	int getX(){return x;}
	PrimeraClase(int n){ x=n;}
};
int main()
{
	PrimeraClase* ptr=new PrimeraClase(5);
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Cabe destacar que en el código que hemos puesto hemos añadido un <strong>public:</strong>, sin especificar para qué. Esto es debido a la <strong>visibilidad</strong>, que trataremos en breve.</p></div>
<div class="paragraph"><p>Al igual que creamos un <strong>constructor</strong>, hay que crear un <strong>destructor</strong>, que será el método que invocaremos al ejecutar un <strong>delete</strong> sobre nuestro objeto.</p></div>
<div class="paragraph"><p>El <strong>destructor va a ser el encargado de liberar la memoria de nuestra máquina. Para crear un *constructor</strong>, tenemos que crear un método que no devuelva nada (ni <strong>void</strong>), no reciba <strong>parámetros</strong>, y se lame como la clase, anteponer el carácter <strong>~</strong>.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class PrimeraClase
{
public:
	int x;
	int getX(){return x;}
	~PrimeraClase(){ x=0;}
};
int main()
{
	PrimeraClase* ptr=new PrimeraClase(5);
	delete ptr;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_visibilidad">
<h2>Visibilidad</h2>
<div class="paragraph"><p>Generalmente, cuando creamos nuestras <strong>clases</strong>, no queremos que todos sus <strong>atributos</strong> puedan ser manipulados externamente. Imaginaros un objeto contenedor que guarda una serie de elementos y un contador que dice cuántos elementos hay, ¿Qué pasaría si un programador accediera y modificara ese valor? probablemente, nada bueno.</p></div>
<div class="paragraph"><p>Surge el concepto de <strong>visibilidad</strong>, o lo que es lo mismo, especificar sobre qué elementos de nuestra clase (<strong>atributos</strong> y <strong>métodos</strong>) pueden ser accedidos directamente, y cuales no.</p></div>
<div class="paragraph"><p>Por defecto, en <strong>C++</strong>, los atributos y métodos de una clase son <strong>privados</strong>. Veamos qué niveles de accesos se pueden definir:</p></div>
<div class="ulist">
<ul>
<li><strong>private:</strong> Cualquier elemento privado es sólo accesible por la propia clase</li>
<li><strong>public:</strong> Cualquier elemento público es accesible externamente</li>
<li><strong>protected:</strong> Sólo accesible por la clase, y cualquier clase que derive de ella</li>
</ul>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Ahora que tenemos claro los tipos de <strong>visibilidad</strong> que se pueden aplicar a una <strong>clase</strong>, es momento de hablar de la <strong>encapsulación</strong>.</p></div>
<div class="paragraph"><p>Por convenio, ningún <strong>atributo</strong> de una <strong>clase</strong> debería ser accesible externamente, es decir, no deberíamos declarar <strong>atributos</strong> como <strong>públicos</strong>.</p></div>
<div class="paragraph"><p>A pesar de ello, en muchas ocasiones necesitamos acceder a los atributos para recoger o alterar sus valores. La solución a esto consiste en crear dos <strong>funciones</strong> por cada <strong>atributo</strong>. Una nos permite obtener su valor (<strong>getter</strong>) y la otra actualizarlo (<strong>setter</strong>).</p></div>
<div class="paragraph"><p>Cuando un atributo, tiene definidas estas dos funciones, decimos que es una <strong>propiedad</strong> de la clase.</p></div>
<div class="paragraph"><p>Por convenio, el <strong>método</strong> que obtiene dicho <strong>atributo</strong> se debe llamar tal como se llama el <strong>atributo</strong>, precedido de <strong>get</strong>, y análogamente, el <strong>método</strong> que actualiza su valor, debe llamarse como el <strong>atributo</strong> precedido de <strong>set</strong>.</p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>¿Cómo quedaría nuestra clase correctamente encapsulada?</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class PrimeraClase
{
private:
	int x;
public:
	int getX(){return x;}
	void setX(int newX){ x = newX;}
	~PrimeraClase(){ x=0;}
};
int main()
{
	PrimeraClase* ptr=new PrimeraClase();
	ptr-&gt;setX(9);
	delete ptr;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_el_puntero_this">
<h2>El puntero this</h2>
<div class="paragraph"><p>Cuando hablamos de <strong>ámbito</strong> de una <strong>varible</strong>, dijimos que una <strong>variable</strong> local definida en un <strong>bloque</strong> interno podía ocultar otra ya definida.</p></div>
<div class="paragraph"><p>¿Qué pasaría si en el ejemplo anterior, el <strong>parámetro</strong> que recibe <strong>setX()</strong> se llamase igual que el atributo <strong>x</strong>? la respuestas rápida es que no podríamos alterar el valor del <strong>atributo</strong>, al no ser visible.</p></div>
<div class="paragraph"><p>Pues bien, existe un <strong>puntero</strong> a la propia instancia dentro de cualquier <strong>método</strong> miembro, el <strong>this</strong>. Siempre que queramos acceder a un <strong>atributo</strong> o <strong>método</strong> de la clase, podemos usar dicho <strong>puntero</strong> para acceder a él.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class PrimeraClase
{
private:
	int x;
public:
	int getX(){return x;}
	void setX(int x){ this-&gt;x = x;}
	~PrimeraClase(){ x=0;}
};</code></pre>
</div>
</div>
</section>
<section class="slide" id="_cabecera_h_y_código_cpp_de_una_clase">
<h2>Cabecera (.h) y código (.cpp) de una clase</h2>
<div class="paragraph"><p>Hasta ahora, los ejemplos de <strong>clases</strong> que habíamos hecho eran sencillos, pero no hemos seguido las prácticas recomendadas.</p></div>
<div class="paragraph"><p>A la hora de crear una <strong>clase</strong>, debemos hacer uso de <strong>dos ficheros distintos</strong>:</p></div>
<div class="ulist">
<ul>
<li><strong>Cabecera</strong>: Por un lado la <strong>definición</strong> de la clase, los <strong>atributos</strong> que va a tener, los <strong>métodos</strong> que va a tener (con sus <strong>parámetros</strong> y tipos <strong>devueltos</strong>), y la visibilidad de todo ello, pero sin la implementación de dichos <strong>métodos</strong>.</li>
<li><strong>Código</strong>: Por otro lado, tenemos que tener la codificación de cada uno de los <strong>métodos</strong> de la clase (que debe incluír una referencia al fichero de <strong>cabecera</strong>).</li>
</ul>
</div>
<div class="paragraph"><p>La <strong>cabecera</strong> se genera en un fichero con extensión <strong>.h</strong>, mientras que el <strong>código</strong> se guarda en un fichero con extensión <strong>.cpp</strong>.</p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Para la clase anterior, nuestro ficheros de <strong>cabecera</strong> y <strong>código</strong> quedarían algo así:</p></div>
<div class="paragraph"><p>PimeraClase.h</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#pragma once
class PrimeraClase
{
private:
	int x;
public:
	int getX();
	void setX(int x);
	~PrimeraClase();
};</code></pre>
</div>
</div>
<div class="paragraph"><p>PimeraClase.cpp</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include "PrimeraClase.h"
int PrimeraClase::getX(){return this-&gt;x;}
void PrimeraClase::setX(int x){this-&gt;x=x;}
PrimeraClase::~PrimeraClase(){x=0;}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Para hacer uso de dicha <strong>clase</strong>, debemos importarla a nuestro programa principal, mediante la directiva <strong>#include "fichero.h"</strong></p></div>
<div class="paragraph"><p>Cómo hacer uso de la clase</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include "PrimeraClase.h"

int main()
{
	PrimeraClase* ptr = new PrimeraClase();
	ptr-&gt;setX(9);
	delete ptr;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_objetos_const">
<h2>Objetos const</h2>
<div class="paragraph"><p>Al igual que podíamos crear una variable de tipo fundamental cuyo valor no íbamos a modificar con <strong>const</strong>, podemos hacer lo mismo al instanciar una <strong>clase</strong>. Cualquier <strong>atributo</strong> de la <strong>clase</strong> sólo puede ser modificado en su <strong>constructor</strong>.</p></div>
<div class="paragraph"><p>Veamos el siguiente código, esto daría error al compilar</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class Prueba {
public:
	int x;
	Prueba(int x){ this-&gt;x = x;}
	int getX() { return x; }
	int setX(int x) { this-&gt;x = x; }
};
int main()
{
	const Prueba* p = new Prueba(3);
	p-&gt;setX(8);
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Sin embargo, si intentamos obtener el valor de <strong>x</strong> mediante el método <strong>getX()</strong> también tendremos un error. Un objeto de tipo <strong>const</strong> sólo puede acceder a funciones tipo <strong>const</strong>. Este tipo de <strong>funciones</strong> garantizan que <strong>NO</strong> va a haber cambios en ningún <strong>atributo</strong> de la clase, ni llamadas a ningún <strong>método no constante</strong>.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class Prueba {
public:
	int x;
	Prueba(int x){ this-&gt;x = x;}
	int getX() const { return x; }
	int setX(int x) { this-&gt;x = x; }
};
int main()
{
	const Prueba* p = new Prueba(3);
	std::cout &lt;&lt; p-&gt;getX() &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Si implementamos la funcion fuera de la definición de la <strong>clase</strong>, también tendremos que hacer uso del modificador <strong>const</strong></p></div>
<div class="paragraph"><p>Prueba.cpp</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include "Prueba.h"

int Prueba::getX() const { return x; }</code></pre>
</div>
</div>
</section>
<section class="slide" id="_atributos_y_métodos_static">
<h2>Atributos y métodos static</h2>
<div class="paragraph"><p>En temas anteriores ya trabajamos con <strong>variables</strong> de tipo <strong>static</strong>, lo cual significaba que sólo existía una instancia de dicha variable durante toda la ejecución del programa.</p></div>
<div class="paragraph"><p>En un bloque del programa, esto significaba que, una vez instanciada la <strong>variable</strong>, esta persistía, y en sucesivas llamadas a dicho código, la variable podía ser utilizada con su valor previo.</p></div>
<div class="paragraph"><p>Pero <strong>static</strong> también se puede especificar para un <strong>atributo</strong> de una <strong>clase</strong>. Este <strong>atributo</strong> no está vinculada a ninguna <strong>instancia</strong>, si no que está vinculado a la propia <strong>clase</strong>, se puede incluso acceder a él sin llegar a tener ninguna <strong>instancia</strong> de dicha <strong>clase</strong>.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class Prueba {
public:
	static int x;
};
int Prueba::x = 9;
int main() {
	std::cout &lt;&lt; Prueba::x;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Para poder acceder al <strong>atributo estático</strong>, hemos tenido que inicializarlo primero, tal como hicimos en el ejemplo anterior. Si hubiésemos intentado acceder a él sin haberlo inicializado, recibiríamos un error de compilación.</p></div>
<div class="paragraph"><p>Esto debería dar un error de compilación</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class Prueba {
public:
	static int x;
};
int main() {
	std::cout &lt;&lt; Prueba::x;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Al igual que añadimos <strong>static</strong> a un <strong>atributo</strong>, podemos aplicarlo a los <strong>métodos</strong>. Un <strong>método estático</strong> puede ser invocado sin existir ninguna <strong>instancia</strong> de nuestra clase, al igual que pasa con los <strong>atributos estáticos</strong>.</p></div>
<div class="paragraph"><p>De manera recíproca, un <strong>método estático</strong> sólo puede acceder a los <strong>atributos estáticos</strong> de la clase. Ojo, sigue habiento que <strong>inicializar</strong> los <strong>atributos estáticos</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class Prueba {
private:
	static int x;
public:
	static void setX(int x) { Prueba::x = x; }
	static int getX() { return Prueba::x; }
};
int Prueba::x = 1;
int main() {
	Prueba::setX(3);
	std::cout &lt;&lt; Prueba::getX();
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_funciones_y_clases_friend">
<h2>Funciones y clases friend</h2>
<div class="paragraph"><p>En ocasiones, nos encontramos con que ciertas <strong>funciones</strong> o <strong>clases</strong> han de trabajar juntas, por ejemplo imaginemos una <strong>clase</strong> que modela un cliente y la que se encarga de mostrar sus datos por pantalla.</p></div>
<div class="paragraph"><p>Vamos a definir una clase que va a ser <strong>amiga</strong> de una <strong>función</strong>. Es decir, dicha <strong>función</strong> va a poder acceder a sus <strong>atributos privados</strong>. Para ello tenemos que declarar la <strong>función</strong> en la propia clase, con el modificador <strong>friend</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class Persona {
private:
	int edad = 33;
public:
	friend void imprimirPersona(Persona* p);
};
void imprimirPersona(Persona* p) {
	std::cout &lt;&lt; "Edad " &lt;&lt; p-&gt;edad  &lt;&lt; std::endl;
}
int main() {
	Persona* p = new Persona();
	imprimirPersona(p);
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Al igual que podemos declarar una <strong>función</strong> como <strong>amiga</strong>, podemos declarar una <strong>clase</strong> como <strong>amiga</strong> de otra. Esta <strong>clase</strong> tendrá acceso a todos los elementos, incluso los <strong>privados</strong>, de la clase.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class Persona {
private:
	int edad = 33;
public:
	friend class MuestraPersona;
};
class MuestraPersona {
public:
	void muestra(Persona* p){
		std::cout &lt;&lt; p-&gt;edad &lt;&lt; std::endl;
	}
};
int main() {
	Persona* p = new Persona();
	MuestraPersona* mp = new MuestraPersona();
	mp-&gt;muestra(p);
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_9_prácticas_iii_la_lista_enlazada">
<h2>9. Prácticas III, la lista enlazada</h2>
<div class="olist arabic">
<ol class="arabic">
<li>
La lista enlazada
</li>
</ol>
</div>
</section>
<section class="slide" id="_la_lista_enlazada">
<h2>La lista enlazada</h2>
<div class="ulist">
<ul>
<li>Realizar la práctica de creación de una lista enlazada, y su prueba (descrito en documento word)</li>
</ul>
</div>
</section>
<section class="slide" id="_10_sobrecarga_de_operadores">
<h2>10. Sobrecarga de operadores</h2>
<div class="olist arabic">
<ol class="arabic">
<li>
Introducción a la sobrecarga de operadores
</li>
<li>
Operadores aritméticos
</li>
<li>
Operadores de flujo E/S
</li>
<li>
Operador de igualdad
</li>
<li>
Otros operadores
</li>
</ol>
</div>
</section>
<section class="slide" id="_introducción_a_la_sobrecarga_de_operadores">
<h2>Introducción a la sobrecarga de operadores</h2>
<div class="paragraph"><p>En temas anteriores hemos visto en qué consiste la <strong>sobrecarga</strong> de <strong>funciones</strong>. Aquellos que vengáis de otros lenguajes, como <strong>java</strong>, estaréis familiarizados con ello. Pero vamos a pararnos un segundo, imaginemos el siguiente código</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main() {
	int x=1;
	float y=0.1;
	x=x+x;
	y=y+y;
}</code></pre>
</div>
</div>
<div class="paragraph"><p>Si nos paramos a pensar, el operador <strong>+</strong>, sería como una función que recibe dos <strong>parametros</strong>. ¿Es lo mismo sumar dos <strong>int</strong> que dos <strong>float</strong>? Evidentemente <strong>NO</strong>. <strong>C++</strong> ya viene preparado para trabajar con los operadores y los <strong>tipos fundamentales</strong>, pero al contrario que otros lenguajes, además nos permite <strong>sobrecargar</strong> dichos <strong>operadores</strong> para poder trabajar con más tipos de datos.</p></div>
</section>
<section class="slide" id="_operadores_aritméticos">
<h2>Operadores aritméticos</h2>
<div class="paragraph"><p><strong>Sobrecargar</strong> un <strong>operador</strong> es muy similar a sobrecargar una función, y se suele realizar:</p></div>
<div class="ulist">
<ul>
<li><strong>Dentro de la propia clase</strong>, si sólo opera con parámetros de la clase</li>
<li><strong>Como función friend</strong>, si opera con otro tipo de datos.</li>
</ul>
</div>
<div class="paragraph"><p>Antes de ver los ejemplos, vamos a indicar los problemas que suelen surgir</p></div>
<div class="ulist">
<ul>
<li>Si la función se implementa dentro de la <strong>clase</strong>, el primer <strong>parámetro</strong> está implícito, es el llamador (el puntero <strong>this</strong>)</li>
<li>Si vamos a operar con <strong>punteros</strong>, antes tenemos que desreferenciarlos</li>
<li>Cuidado con crear un objeto local, se perderá al finalizar el bloque</li>
<li>Por convención, las operadores aritméticos <strong>binarios</strong> devuelven <strong>referencias a variables</strong> (<strong>tipo&</strong>), y los <strong>parámetros</strong> que reciben se pasan como <strong>referencias constantes</strong> (<strong>const tipo&</strong>)</li>
<li>Si trabajamos con operadores <strong>unarios</strong> también devuelven <strong>referencias a variables</strong>, pero el primer parámetro <strong>nunca</strong> puede ir como <strong>const</strong>, el segundo depende.</li>
</ul>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Veamos un ejemplo sencillo, en el que se sobrecargan los operadores de las dos maneras:</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class MiEntero{
private:
	int entero;
public:
	MiEntero(int entero) { this-&gt;entero = entero; }
	int getEntero() { return entero; }
	friend MiEntero&amp; operator+(const MiEntero&amp; e1, const MiEntero&amp; e2);
	MiEntero&amp; operator-(const MiEntero&amp; e2) {
		return MiEntero(this-&gt;entero - e2.entero);
	}
};
MiEntero&amp; operator+(const MiEntero&amp; e1, const MiEntero&amp; e2) {
	return MiEntero(e1.entero + e2.entero);
}
int main() {
	MiEntero e1(8);
	MiEntero e2(3);
	MiEntero e3 = e1 + e2;
	MiEntero e4 = e1 - e2;
	std::cout &lt;&lt; e3.getEntero() &lt;&lt; " " &lt;&lt; e4.getEntero() &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Vamos a hacer un pequeño ejercicio:</p></div>
<div class="ulist">
<ul>
<li>Queremos crear una claes <strong>Punto</strong>, que poseerá 2 atributos <strong>int</strong> (x,y) y representará un punto en un plano 2D. Sobrecargaremos los operadores <strong>+</strong> y <strong>-</strong>, y para probar, crearemos 2 puntos en un programa con valores dados, crearemos un tercer punto que será la suma de los anteriores, y un cuarto punto que será la resta.</li>
</ul>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Una solución (tanto con <strong>friend</strong> como dentro de la <strong>clase</strong>):</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class Punto {
public:
	int x;
	int y;
	Punto&amp; operator-(/*Punto p1, es this*/ const Punto&amp; p2) {
		Punto* p = new Punto();
		p-&gt;x = this-&gt;x - p2.x;
		p-&gt;y = this-&gt;y - p2.y;
		return *p;
	}
	friend Punto&amp; operator+( Punto p1, const Punto&amp; p2) {
		Punto* p = new Punto();
		p-&gt;x = p1.x + p2.x;
		p-&gt;y = p1.y + p2.y;
		return *p;
	}

};
int main() {
	Punto* p = new Punto();
	p-&gt;x = 1;
	p-&gt;y = 3;
	Punto* p3 =&amp;(*p + *p);
	Punto* p4 = &amp;(*p - *p);
	std::cout &lt;&lt;" " &lt;&lt; p3-&gt;x &lt;&lt; " " &lt;&lt; p4-&gt;x  &lt;&lt; std::endl;

}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Cabe resaltar un par de cosas del ejercicio anterior:</p></div>
<div class="ulist">
<ul>
<li>Hemos tenido que <strong>desreferenciar</strong> los punteros para poder hacer uso del <strong>operador</strong>.</li>
<li>Hemos tenido que <strong>reservar</strong> con memoria dinámica el espacio para el objeto resultado, pues si no, se perdería al finalizar</li>
<li>Hemos tenido que <strong>desreferenciar</strong> el objeto resultado, porque no es muy intuitivo que dos objetos básicos devuelvan un puntero, y luego hemos <strong>referenciado</strong> nuevamente</li>
</ul>
</div>
<div class="paragraph"><p>Si intentáramos hacer algo parecido (trabajar con punteros) con <strong>MiEntero</strong>, esto no funcionaría, pues al ser punteros, perdemos la referencia. Probadlo:</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main() {
	MiEntero* e1=new MiEntero(8);
	MiEntero* e2=new MiEntero(3);
	MiEntero* e3 = &amp;(*e1 + *e2);
	MiEntero* e4 = &amp;(*e1 - *e2);
	std::cout &lt;&lt; e3-&gt;getEntero() &lt;&lt; " " &lt;&lt; e4-&gt;getEntero() &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_operadores_de_flujo_e_s">
<h2>Operadores de flujo E/S</h2>
<div class="paragraph"><p>Al igual que sobrecargamos los <strong>operadores aritméticos</strong>, podemos sobrecargar los operadores de <strong>I/O</strong>. La única diferencia es que el primer <strong>parámetro</strong> del <strong>operador</strong>, y el tipo <strong>devuelto</strong>, son siempre <strong>ostream</strong> para salida y <strong>istream</strong> para entrada. Estas sobrecargas actúan sobre la clase <strong>ostream</strong>, por lo que tenemos que definirlas con funciones <strong>friend</strong></p></div>
<div class="paragraph"><p>Repasémoslo con nuestra clase <strong>MiEntero</strong> (recordemos que <strong>ostream</strong> es una clase perteneciente a <strong>std</strong>)</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class MiEntero {
private:
	int entero;
public:
	MiEntero(int entero) { this-&gt;entero = entero; }
	int getEntero() { return entero; }
	[...]
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MiEntero e);

};
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MiEntero e) {
	out &lt;&lt; e.entero;
	return out;
}
int main() {
	MiEntero e1(8);
	MiEntero e2(3);
	MiEntero e3 = e1 + e2;
	std::cout &lt;&lt; e3 &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Repitamos lo mismo con la clase <strong>Punto</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class Punto {
public:
	int x;
	int y;
	[...]
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Punto&amp; p);
};
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Punto&amp; p) {
	out &lt;&lt; "(" &lt;&lt; p.x &lt;&lt; "," &lt;&lt; p.y &lt;&lt; ")";
	return out;
}
int main(){
	Punto* p = new Punto();
	p-&gt;x = 1;
	p-&gt;y = 3;
	std::cout &lt;&lt; *p &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Sobrecargar el operador de entrada <strong>>></strong> es análogo (salvo que el <strong>parámetro destino</strong>, el segundo parámetro, <strong>NO</strong> puede ser <strong>const</strong>), mostraremos un ejemplo sencillo</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class Punto {
public:
[...]
	friend std::istream&amp; operator&gt;&gt;(std::istream&amp; in, Punto&amp; p);
};
std::istream&amp; operator&gt;&gt;(std::istream&amp; in, Punto&amp; p){
	in &gt;&gt; p.x;
	in &gt;&gt; p.y;
	return in;
}
int main(){
	Punto p5;
	std::cout &lt;&lt; "Introduzca el punto" &lt;&lt; std::endl;
	std::cin &gt;&gt; p5;
	std::cout&lt;&lt; p5 &lt;&lt; std::endl;
	}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_operador_de_igualdad">
<h2>Operador de igualdad</h2>
<div class="paragraph"><p>Bueno, llegamos a uno de los puntos más útiles, <strong>sobrecargar</strong> la <strong>comparación</strong>, el <strong>==</strong>.</p></div>
<div class="paragraph"><p><strong>Sobrecargar</strong> este <strong>operador</strong> es bastante similar a lo anterior, con la salvedad de que devuelve un <strong>bool</strong>. Al igual que con otros operadores, podemos declararlo dentro de la <strong>clase</strong> o como funciones <strong>friend</strong>.</p></div>
<div class="paragraph"><p>Veamos un ejemplo para la clase MiEntero</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class MiEntero {
private:
	int entero;
public:
	[...]
	bool operator==(const MiEntero&amp; e2) {
		return (this-&gt;entero == e2.entero);
	}
};

int main() {
	MiEntero e1(8);
	MiEntero e2(8);
	if (e1 == e2) { std::cout &lt;&lt; "Son iguales" &lt;&lt; std::endl; }
	else { std::cout &lt;&lt; "Son distintos" &lt;&lt; std::endl; }
}</code></pre>
</div>
</div>
<div class="paragraph"><p>Hagamos lo mismo usando la clase <strong>Punto</strong>, y trabajando con <strong>punteros</strong></p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Sobrecargando el <strong>==</strong> en la clase <strong>Punto</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class Punto {
public:
	[...]
	bool operator==(const Punto&amp; p) {
		return (this-&gt;x == p.x &amp;&amp; this-&gt;y==p.y);
	}
};
int main() {
	Punto* p = new Punto();
	p-&gt;x = 1;	p-&gt;y = 3;
	Punto* p2 = new Punto();
	p2-&gt;x = 1;	p2-&gt;y = 3;
	if ( *p == *p2) { std::cout &lt;&lt; "Son iguales" &lt;&lt; std::endl; }
	else { std::cout &lt;&lt; "Son distintos" &lt;&lt; std::endl; }
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_otros_operadores">
<h2>Otros operadores</h2>
<div class="paragraph"><p>También existe la posibilidad de <strong>sobrecargar</strong> otros operadores, como el operador unario <strong>-</strong>, el postincremente <strong>var*, el preincremento *var</strong>&#8230;&#8203;
Vamos a dejar algún ejemplo, pero no vamos a entrar en detalle en estos operadores</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class Punto {
	[...]
	Punto&amp; operator- ()	{
		Punto* p = new Punto();
		p-&gt;x = -this-&gt;x; p-&gt;y = -this-&gt;y;
		return *p;
	}
	Punto&amp; operator++() {//preincremento
		this-&gt;x++; this-&gt;y++;
		return *this;
	}
	Punto operator++(int){//postincremento
		Punto* nuevo = new Punto();
		nuevo-&gt;x = this-&gt;x; nuevo-&gt;y = this-&gt;y;
		++(*this);
		return *nuevo;
	}
};
void main(){
	Punto* p = new Punto();
	p-&gt;x = 1;	p-&gt;y = 3;
	std::cout &lt;&lt; (-*p) &lt;&lt;" "&lt;&lt; (*p)++ &lt;&lt; " " &lt;&lt; ++(*p) &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>En realidad, la <strong>sobrecarga de operadores</strong> no acaba aquí, pueden llegar a sobrecargarse los accesos por índice <strong>[]</strong>, los paréntesis <strong>()</strong>, e incluso los <strong>castings</strong>, pero no vamos a entrar en esto ya que no es muy habitual trabajar con ellos.</p></div>
<div class="paragraph"><p>Si es habitual sin embargo que se sobreescriba el operador de <strong>asignación</strong>, pero para ello se suele definir un <strong>constructor</strong> de copia, por lo que de momento lo dejamos para ma adelante (cuando entendamos los conceptos de <strong>copia ligera</strong> y <strong>copia profunda</strong>)</p></div>
</section>
<section class="slide" id="_11_agregación_composición_inicializadores_de_constructor">
<h2>11. Agregación, composición, inicializadores de constructor</h2>
<div class="olist arabic">
<ol class="arabic">
<li>
Inicializadores de constructor
</li>
<li>
Composición
</li>
<li>
Agregación
</li>
</ol>
</div>
</section>
<section class="slide" id="_inicializadores_de_constructor">
<h2>Inicializadores de constructor</h2>
<div class="paragraph"><p>Hasta ahora, en un <strong>constructor</strong> habíamos inicializado <strong>atributos</strong> mediante el operador de asignación. No obstante, esto no nos habría valido para valores <strong>const</strong>, ya que no permiten la asignación salvo en la declaración.</p></div>
<div class="paragraph"><p>Existe una vía diferente para incializar elementos en el constructor, las listas de incializadores. Es muy similar a definir una variable con valor implícito, se añaden los <strong>inicializadores</strong> detrás de la declaración del <strong>constructor</strong>, precedido por el símbolo <strong>:</strong>.</p></div>
<div class="paragraph"><p>Veamos un ejemplo</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class PuntoFijo {
public:
	const int x;
	const int y;
	PuntoFijo(int x, int y): x(x),y(y)
	{}
};
void main(){
	PuntoFijo* p = new PuntoFijo(2,4);
	std::cout &lt;&lt; p-&gt;x &lt;&lt; " " &lt;&lt; p-&gt;y &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_composición">
<h2>Composición</h2>
<div class="paragraph"><p>En ocasiones, nuestros <strong>objetos</strong> están hechos de otra serie de <strong>objetos</strong> más pequeños, y la creación de uno de estos <strong>objetos</strong> es la <strong>composición</strong> de varios de ellos.</p></div>
<div class="paragraph"><p>Pongamos como ejemplo un triángulo. Un triángulo se define por 3 puntos de un plano, por lo que la <strong>clase</strong> triángulo tendrá 3 atributos de tipo <strong>Punto</strong>. Podemos <strong>inicializar</strong> diréctamente estos elementos que no son tipos <strong>fundamentales</strong> de la misma manera que habíamos hecho antes:</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class Triangulo {
public:
	PuntoFijo p1;
	PuntoFijo p2;
	PuntoFijo p3;
	Triangulo(int p1_x, int p1_y, int p2_x, int p2_y, int p3_x, int p3_y) : p1(p1_x,p1_y), p2(p2_x, p2_y), p3(p3_x, p3_y)
	{}
};
void main() {
	Triangulo* t = new Triangulo(1, 1, 3, 3, 9, 9);
	std::cout &lt;&lt; t-&gt;p1.x &lt;&lt; " " &lt;&lt; t-&gt;p1.y &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_agregación">
<h2>Agregación</h2>
<div class="paragraph"><p>Cuando el objeto <strong>compuesto</strong> desparece, todos los <strong>subobjetos</strong> que se crearon con él, también desaparecen.</p></div>
<div class="paragraph"><p>La <strong>agregacion</strong> es similar a la <strong>composición</strong>, con la salvedad de que los <strong>objetos agregados</strong> no son <strong>poseídos</strong> por el objeto complejo. Esto se resuelve de manera muy sencilla, en lugar de declararlos como <strong>variable local</strong>, los declaramos como <strong>punteros</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class Triangulo {
public:
	PuntoFijo* p1;
	PuntoFijo* p2;
	PuntoFijo* p3;
	Triangulo(PuntoFijo* p1,PuntoFijo* p2,PuntoFijo* p3) : p1(p1), p2(p2), p3(p3)
	{}
};
void main() {
	PuntoFijo* p1= new PuntoFijo(1,2);
	Triangulo* t = new Triangulo(p1,p1,p1);
	std::cout &lt;&lt; t-&gt;p1-&gt;x &lt;&lt; " " &lt;&lt; t-&gt;p1-&gt;y &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_12_herencia">
<h2>12. Herencia</h2>
<div class="olist arabic">
<ol class="arabic">
<li>
Introducción a la herencia
</li>
<li>
Herencia básica
</li>
<li>
Especificaciones de acceso (visibilidad)
</li>
<li>
Accediendo a miembros y cambiando su visibilidad
</li>
<li>
Herencia Múltiple
</li>
<li>
Clases bases virtuales
</li>
</ol>
</div>
</section>
<section class="slide" id="_introducción_a_la_herencia">
<h2>Introducción a la herencia</h2>
<div class="paragraph"><p>Hasta ahora habíamos visto como construir <strong>clases</strong> simples, con tipos fundamentales, o cómo construir <strong>clases</strong> más complejas por medio de la <strong>composición</strong>, haciendo que sus <strong>atributos</strong> fueran otras clases, donde se establecía una <strong>relación</strong> de <strong>posesión</strong> (Un triángulo posee 3 puntos&#8230;&#8203;)</p></div>
<div class="paragraph"><p>La <strong>herencia</strong> es un enfoque distinto, es coger una <strong>clase</strong> ya existente y <strong>ampliarla</strong>, para especializarla. Es muy habitual que a la hora de programar descubramos que necesitamos varias <strong>clases</strong> similares, que difieren en algunos aspectos.</p></div>
<div class="paragraph"><p>Imaginemos que montamos una tienda on-line. Por supuesto, tendremos <strong>clientes</strong> que realizarán compras, pero también <strong>administradores</strong> que añadirán productos. Estas clases van a tener muchos datos similares. Tiene sentido entonces tener una clase <strong>padre</strong> con estos <strong>atributos</strong>, y especializarla en cada una de las clases <strong>hija</strong></p></div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="persona" src="images/diagrams/persona.PNG">
</div>
<div class="title">Figure 13. Herencia en nuestra comercio On-Line</div>
</div>
<div class="paragraph"><p>La clase de la cuál se hereda se denomina <strong>clase padre</strong>, las clases que extienden a la clase padre, se denomina <strong>clases hijas</strong>.</p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Las <strong>clases hijas</strong> reciben todos los <strong>atributos</strong> y <strong>métodos</strong> de la <strong>clase padre</strong>, pero hay un aspecto muy importante: <strong>pueden redefinirlas</strong>.</p></div>
<div class="paragraph"><p>Se pueden definir jerarquías tan complejas como consideremos, por ejemplo si definimos formas, un cuadrado es un tipo de rectángulo, que es a su vez un tipo de cuadrilatero, que a su vez es un tipo de figura&#8230;&#8203;</p></div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="ShapesInheritance" src="images/diagrams/ShapesInheritance.png">
</div>
<div class="title">Figure 14. Herencia con figuras</div>
</div>
</section>
<section class="slide" id="_herencia_básica">
<h2>Herencia básica</h2>
<div class="paragraph"><p>Ahora que ya sabemos en qué consiste la <strong>herencia</strong>, vamos a aplicarla a <strong>C++</strong>. Vamos a definir la clase <strong>padre</strong> y posteriormente crearemos las clases <strong>hijas</strong> que heredarán de ella.</p></div>
<div class="paragraph"><p>Clase Persona</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class Persona {
private:
	std::string nombre;
	int edad;
public:
	Persona(std::string nombre, int edad) : nombre(nombre), edad(edad)
	{}
	int getEdad() { return edad; }
	std::string getNombre() { return nombre; }
	void saluda() { std::cout &lt;&lt; "Soy una persona " &lt;&lt; std::endl; }
};</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Vamos a crear una clase <strong>hija</strong>, para ello, en la definición de la <strong>clase</strong> tenemos que decir de quién <strong>hereda</strong>, y de qué manera (lo veremos más adelant)</p></div>
<div class="paragraph"><p>Clase Cliente</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class Cliente: public Persona {
private:
	std::string direccion;
public:
	Cliente(std::string nombre, int edad, std::string direccion) : Persona(nombre, edad), direccion(direccion)
	{}
	std::string getDireccion() { return direccion; }
	void saluda() { std::cout &lt;&lt; "Soy un cliente " &lt;&lt; std::endl; }
};</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>En el código anterior hay que resaltar los siguientes puntos:</p></div>
<div class="ulist">
<ul>
<li>Hemos indicado de quién <strong>hereda</strong> Cliente, en la declaración de la clase hemos añadido un <strong>public Persona</strong>. Esto afectará a la visibilidad (lo veremos más adelante).</li>
<li>Para inicializar los <strong>atributos</strong> de la clase <strong>padre</strong>, hemos llamado a su <strong>constructor</strong>, mediante <strong>composición</strong>. Siempre, aunque sea de manera <strong>implícita</strong>, se llama al constructor de la clase <strong>padre</strong>. Si no tenemos <strong>constructor por defecto</strong> y no llamamos a ningún constructor, nuestro programa <strong>NO</strong> compilará</li>
<li>Hemos <strong>redefinido</strong> el comportamiento de la <strong>función</strong> saluda</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">void main() {
	Persona* p = new Persona(std::string("Juan"),44);
	Cliente* c = new Cliente(std::string("Luis"), 28, std::string("Calle molona 8"));
	p-&gt;saluda();
	c-&gt;saluda();
	std::cout &lt;&lt; c-&gt;getNombre() &lt;&lt; " tiene " &lt;&lt; c-&gt;getEdad() &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Por ahondar un poco más en la inicialización de una <strong>clase derivada</strong>, veamos un ejemplo algo más complejo:</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class A {
public:
	int a;
	A(int a) :a(a) {};
};
class B: public A {
public:
	int b;
	B(int a, int b): A(a), b(b) {};
};
class C : public B {
public:
	int c;
	C(int a, int b, int c): B(a,b), c(c) {};
};</code></pre>
</div>
</div>
</section>
<section class="slide" id="_especificaciones_de_acceso_visibilidad">
<h2>Especificaciones de acceso (visibilidad)</h2>
<div class="paragraph"><p>Recordemos lo que vimos en temas anteriores. Los <strong>atributos</strong> y <strong>métodos</strong> de una <strong>clase</strong> tenían que especificar una de las tres <strong>visibilidades</strong> disponibles en <strong>C++</strong></p></div>
<div class="ulist">
<ul>
<li><strong>public:</strong> &#8594; Cualquiera podía acceder a ello</li>
<li><strong>private:</strong> &#8594; Sólo la clase puede acceder a ello, ni siquiera las clases derivadas</li>
<li><strong>protected:</strong> &#8594; Sólo la clase y cualquiera que derive de ella, puede acceder a ello.</li>
</ul>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Hemos estado viendo que, al igual que definíamos distintas secciones de una clase para otorgarles una <strong>visibilidad</strong> u otra, a la hora de <strong>heredar</strong> también aplicábamos un modificador sobre la clase <strong>padre</strong></p></div>
<div class="paragraph"><p>Esto es de vital importancia, ya que la forma en la que <strong>heredamos</strong> de una <strong>clase padre</strong>, puede modificar la <strong>visibilidad</strong> de los <strong>Atributos heredados</strong></p></div>
<div class="paragraph"><p>Imaginemos esta clase</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class T {
public:
	int publico;
private:
	int private;
protected:
	int protected;
};</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Si hacemos una nueva clase que herede de manera <strong>pública</strong> de T, heredará todos sus atributos, pero además <strong>NO</strong> modificará su visibilidad (este tipo de herencia es la más habitual)</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class HijaPublica: public T {
//int publico; será un atributo heredado público
//int protected; será un atributo heredado protegido
//int private; será un atributo heredado privado AL QUE NO TENDRÁ ACCESO
};</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Si heredamos de manera <strong>protegida</strong> de nuestra clase T, heredará todos los atriutos, pero además cambiará la visibilidad de los <strong>públicos</strong> a <strong>protegidos</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class HijaProtegida: protected T {
//int publico; será un atributo heredado protegido
//int protected; será un atributo heredado protegido
//int private; será un atributo heredado privado AL QUE NO TENDRÁ ACCESO
};</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Por último, al heredar de manera <strong>privada</strong> de nuestra clase T, heredaremos todos los atributos, pero cambiaremos la visibilidad a <strong>privado</strong> a todos ellos.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class HijaProtegida: protected T {
//int publico; será un atributo heredado privado AL QUE SE PUEDE ACCEDER
//int protected; será un atributo heredado privado AL QUE SE PUEDE ACCEDER
//int private; será un atributo heredado privado AL QUE NO TENDRÁ ACCESO
};</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>A modo de resumen, podemos ver las siguientes tablas:</p></div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="herencia public" src="images/pics/herencia_public.PNG">
</div>
<div class="title">Figure 15. Herencia pública</div>
</div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="herencia protected" src="images/pics/herencia_protected.PNG">
</div>
<div class="title">Figure 16. Herencia protegida</div>
</div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="herencia private" src="images/pics/herencia_private.PNG">
</div>
<div class="title">Figure 17. Herencia privada</div>
</div>
</section>
<section class="slide" id="_accediendo_a_miembros_y_cambiando_su_visibilidad">
<h2>Accediendo a miembros y cambiando su visibilidad</h2>
<div class="paragraph"><p>Ya hemos visto que podemos redefinir el comportamiento de una <strong>función</strong> ya existente, pero ¿y si queremos acceder a la <strong>función heredada</strong> en lugar de a nuestra <strong>función</strong>?.</p></div>
<div class="paragraph"><p>Pues muy sencillo, hacemos uso de nuestro <strong>Scope Resolution Operator</strong>, el operador <strong>::</strong>, para indicarle que queremos acceder a la <strong>función</strong> de otra <strong>clase</strong>.</p></div>
<div class="paragraph"><p>En nuestro ejemplo Persona &#8594; Cliente, teníamos redefinida la función Saluda(). Vamos a ver cómo podríamos llamar a la función del <strong>padre</strong></p></div>
<div class="paragraph"><p>Clase Cliente</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class Cliente: public Persona {
[...[
	void saluda() {
		Persona::saluda();
		std::cout &lt;&lt; "Soy un cliente " &lt;&lt; std::endl; }
};</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>En otras ocasiones nos puede interesar alterar la visibilidad de un <strong>atributo</strong> o <strong>método</strong> ya definido (siempre y cuando tengamos acceso a él). En el siguiente ejemplo vamos a hacer <strong>privado</strong> un método que heredamos como público</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class A{
public:
	void m() {std::cout&lt;&lt;"M";}
};
class B: public A{
private:
	A::M;
};</code></pre>
</div>
</div>
<div class="paragraph"><p>Esto podemos hacerlo con elementos <strong>públicos</strong> y <strong>protegidos</strong>, pero no podemos alterar la visibilidad de elementos <strong>privados</strong> puesto que no tenemos acceso.</p></div>
</section>
<section class="slide" id="_herencia_múltiple">
<h2>Herencia Múltiple</h2>
<div class="paragraph"><p>Hasta ahora, todo lo que habíamos visto habían sido casos de <strong>herencia simple</strong>. En <strong>C++</strong> existe la posibilidad de <strong>heredar</strong> de más de una <strong>clase</strong> (esto en <strong>Java</strong> no es posible, por ejemplo).</p></div>
<div class="paragraph"><p>la <strong>herencia múltiple</strong> consiste en heredar de más de una clase padre, y su implementacion es tan sencilla como indicar de qué <strong>clases</strong> heredamos separándolo por comas.</p></div>
<div class="paragraph"><p>Imaginemos que a nuestro ejemplo de Persona &#8594; Cliente añadimos una nueva clase, Evaluador. El evaluador valora la calidad, podríamos tener clases Cliente sin heredar de Evaluador y otra clase ClienteEvaluador que si heredase.</p></div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="evaluador" src="images/diagrams/evaluador.PNG">
</div>
<div class="title">Figure 18. Diagrama de clases nuevo</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Ejemplo de herencia múltiple</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class Evaluador{
public:
	int esEvaluador;
};
public Cliente: public Persona, public Evaluador{
	[...]
	Cliente(std::string nombre, int edad, int evaluador, std::string direccion):
		Persona(nombre, edad), Evaluador(evaluador), direccion(direccion)
	{}
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>El problema de la <strong>herencia múltiple</strong> es que podemos llegar a tener funciones o atributos heredados <strong>duplicados</strong>, y esto significa que el <strong>compilador</strong> encuentra una <strong>ambigüedad</strong>.</p></div>
<div class="paragraph"><p>Veamos este ejemplo:</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class A {
public:
	void saluda() { std::cout &lt;&lt; "Hola A" &lt;&lt; std::endl; }
};
class B {
public:
	void saluda() { std::cout &lt;&lt; "Hola B" &lt;&lt; std::endl; }
};
class C: public A, public B {

};
void main() {
	C* c = new C();
	c-&gt;saluda();
}</code></pre>
</div>
</div>
<div class="paragraph"><p>El compilador nos da un error, debido a la ambigüedad existente con la función <strong>saluda()</strong>.</p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>¿Podemos resolver este problema?</p></div>
<div class="paragraph"><p>En este caso se puede, especificando cuál de las dos funciones queremos llamar, mediante el <strong>Scoope Resolution Operator</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">void main() {
	C* c = new C();
	c-&gt;A::saluda();
}</code></pre>
</div>
</div>
<div class="paragraph"><p>Pero esto es sólo un parche, que no nos va a servir para todas las situaciones</p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Veamos este otro caso, volvemos a tener el mismo problema, tendríamos que volver a recurrir a añadir un <strong>Scoope Resolution Operator</strong>, pero seguimos construyendo dos veces la clase A, y podría ser todavía más complicado</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class A {
public:
	void saluda() { std::cout &lt;&lt; "Hola A" &lt;&lt; std::endl; }
	A() { std::cout &lt;&lt; "Creado A" &lt;&lt; std::endl; }
};
class B: public A {
};
class C: public A{
};
class D : public B, public C {};
void main() {
	D* d = new D();
	d-&gt;saluda();
}</code></pre>
</div>
</div>
<div class="paragraph"><p>¿No hay una solución a esto? Además, ¿Se va a tener que construir 2 veces la clase A?</p></div>
</section>
<section class="slide" id="_clases_bases_virtuales">
<h2>Clases bases virtuales</h2>
<div class="paragraph"><p>Existe una manera de evitar heredar dos veces de la misma clase, gracias a <strong>virtual</strong>. La idea es indicar que vamos a <strong>heredar</strong> de una <strong>clase</strong>, pero que es posible que dicha <strong>herencia</strong> venga también por otro lado.</p></div>
<div class="paragraph"><p>En términos técnicos, lo que estamos es indicando que heredamos de una <strong>clase base virtual</strong>. Si indicamos esto, el compilador se va a asegurar que no haya más de una <strong>instancia</strong> de dicha <strong>clase base</strong>, independientemente de las veces que hayamos heredado indirectamente de ella.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class A {
public:
	void saluda() { std::cout &lt;&lt; "Hola A" &lt;&lt; std::endl; }
	A() { std::cout &lt;&lt; "Creado A" &lt;&lt; std::endl; }
};
class B: virtual public A {
};
class C: virtual public A{
};
class D : public B, public C {};
void main() {
	D* d = new D();
	d-&gt;saluda();
}</code></pre>
</div>
</div>
<div class="paragraph"><p>No confundir las <strong>herencias virtuales</strong> con las <strong>funciones virtuales</strong>, que veremos en el siguiente tema</p></div>
</section>
<section class="slide" id="_13_funciones_virtuales">
<h2>13. Funciones virtuales</h2>
<div class="olist arabic">
<ol class="arabic">
<li>
Punteros a la clase padre y a la clase hija
</li>
<li>
Funciones virtuales
</li>
<li>
Clases abstractas y Funciones virtuales puras
</li>
<li>
Clases interface
</li>
</ol>
</div>
</section>
<section class="slide" id="_punteros_a_la_clase_padre_y_a_la_clase_hija">
<h2>Punteros a la clase padre y a la clase hija</h2>
<div class="paragraph"><p>Aquellos que vengáis de <strong>Java</strong>, conoceréis seguro el truco de "Cualquier puntero a una clase, puede apuntar a un objeto que herede de ella".</p></div>
<div class="paragraph"><p>¿Puede hacerse esto en <strong>C++</strong>? Si, se puede. Podemos apuntar a cualquier <strong>clase</strong> con un puntero de la <strong>clase padre</strong> (o abuela&#8230;&#8203;), incluso podemos crear una <strong>referencia</strong> del tipo <strong>padre</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class A {
public:
	void saluda() { std::cout &lt;&lt; "Hola A" &lt;&lt; std::endl; }
};
class B: public A {
public:
	void saluda() { std::cout &lt;&lt; "Hola B" &lt;&lt; std::endl; }
};
void main()
{
	A* a=new B();
	A&amp; ref_a=*a;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Sin embargo, hay una cosa que no parece ser muy lógica, fijémonos en el siguiente código:</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">void main()
{
	B* b=new B();
	A* a=b;
	A&amp; ref_a=*a;
	b-&gt;saluda();
	a-&gt;saluda();
	ref_a.saluda();
}</code></pre>
</div>
</div>
<div class="paragraph"><p>¿Qué salida genera este código? ¿Es la salida que esperamos? Las 3 variables en realidad trabajan con el mismo objeto&#8230;&#8203;</p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Al trabajar con un <strong>puntero</strong> a la clase <strong>padre</strong>, sólo podemos acceder y trabajar con las <strong>funciones</strong> y <strong>atributos</strong> de la clase a la que pertenece el puntero, a pesar de haber <strong>redefinido</strong> el comportamiento de la <strong>función</strong> saluda, se invoca a la <strong>función</strong> de la clase a la que pertenece el puntero.</p></div>
<div class="paragraph"><p>Aquí no hay posibilidad de hacer uso del <strong>Scoope Resolution Operator</strong>. Podríamos llegar a hacer uso de un <strong>casting</strong> para solucionarlo, pero tampoco es lo más adecuado</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">void main()
{
	B* b=new B();
	A* a=b;
	b-&gt;saluda();
	(static_cast&lt;B*&gt;(a))-&gt;saluda();
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Puede parecer trivial, pero en <strong>C++</strong> es muy importante poder trabajar con un <strong>puntero</strong> de la clase <strong>padre</strong> apuntando a objetos de las clases <strong>hijas</strong>.</p></div>
<div class="paragraph"><p>Esto se hace porque queremos <strong>redefinir</strong> una función de la clase <strong>padre</strong> en todas las <strong>hijas</strong>, para poder realizar un tratamiento conjunto de todas ellas, pero claro, acabamos de ver que esto no ha funcionado.</p></div>
<div class="paragraph"><p>Pues existe una manera en <strong>C++</strong> de resolver este problema, las <strong>funciones virtuales</strong></p></div>
</section>
<section class="slide" id="_funciones_virtuales">
<h2>Funciones virtuales</h2>
<div class="paragraph"><p>Una <strong>función virtual</strong> es un tipo especial de <strong>función</strong> que resuelve la mayoría de problemas relacionados con la <strong>herencia</strong> de una <strong>función</strong>.</p></div>
<div class="paragraph"><p>Si queremos que nuestro objeto llame a la <strong>función</strong> que corresponde a su <strong>clase</strong> y no a su <strong>puntero</strong>, tenemos que definir dicha función como <strong>virtual</strong> en la clase <strong>padre</strong>.</p></div>
<div class="paragraph"><p>El compilador se <strong>encargará</strong>, en tiempo de ejecución, de decidir qué función debe ser llamada.</p></div>
<div class="paragraph"><p>Aunque no es necesario, se recomienda definir también en la <strong>clase hija</strong> la <strong>función</strong> como <strong>virtual</strong>, pero se recomienda dejarlas marcadas como <strong>virtuales</strong>, por si son heredadas o como recordatorio.</p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Veamos cómo quedaría el ejemplo anterior haciendo uso de las <strong>funciones virtuales</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class A {
public:
	virtual void saluda() { std::cout &lt;&lt; "Hola A" &lt;&lt; std::endl; }
};
class B: public A {
public:
	virtual void saluda() { std::cout &lt;&lt; "Hola B" &lt;&lt; std::endl; }
};
void main()
{
	A* a=new B();
	a-&gt;saluda();
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Además de poder crear <strong>funciones virtuales</strong>, es muy importante crear también <strong>destructores virtuales</strong>, ya que un destructor se <strong>comportaría</strong> al igual que una <strong>función</strong>, se invocaría exclusivamente al <strong>destructor</strong> de la clase a la que pertenezca el <strong>puntero</strong>, con lo que tendríamos un problema de <strong>memory leak</strong>.</p></div>
<div class="paragraph"><p>Una puntualización, no se puede hacer <strong>virtual</strong> el <strong>operador de asignación</strong></p></div>
<div class="paragraph"><p>Ejemplo de destructor virtual</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class A {
public:
	virtual void saluda() { std::cout &lt;&lt; "Hola A" &lt;&lt; std::endl; }
	virtual ~A() { std::cout &lt;&lt; "A borrado" &lt;&lt;std::endl;}
};
class B: public A {
public:
	virtual void saluda() { std::cout &lt;&lt; "Hola B" &lt;&lt; std::endl; }
	virtual ~B() { std::cout &lt;&lt; "B borrado" &lt;&lt;std::endl;}
};
void main(){
	A* a = new B();
	delete a;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Por si tenéis interés en cómo funcionan las <strong>funciones virtuales</strong>, podemos hablar del <strong>early binding</strong> y el <strong>late binding</strong>.</p></div>
<div class="ulist">
<ul>
<li>El <strong>early binding</strong> hace referencia a la resolución en tiempo de compilación de la dirección de una función que se va a <strong>invocar</strong></li>
<li>El <strong>late binding</strong> indica que dicha resolucion se realiza en tiempo de ejecución</li>
</ul>
</div>
<div class="paragraph"><p>Existe una tabla llamada <strong>tabla virtual</strong> en la que se almacenan los métodos de las clases. Cuando creamos un objeto de un tipo, este posee un <strong>atributo oculto</strong> llamado <strong>*_vptr</strong> que apunta a dicha tabla, y permite a la <strong>clase</strong> resolver en tiempo de ejecución qué <strong>funciones</strong> deben ser invocadas.</p></div>
</section>
<section class="slide" id="_clases_abstractas_y_funciones_virtuales_puras">
<h2>Clases abstractas y Funciones virtuales puras</h2>
<div class="paragraph"><p>Las <strong>funciones virtuales puras</strong> o <strong>funciones abstractas</strong>, son funciones cuyo <strong>cuerpo</strong> no se va a proporcionar, sirven únicamente de aviso para que cualquier clase <strong>hija</strong> deba implementar dicha <strong>función</strong>.</p></div>
<div class="paragraph"><p>Para declarar una <strong>función</strong> como <strong>virtual pura</strong>, tan sólo tenemos que declarar en la <strong>clase padre</strong> dicha función como virtual, y asignamos a dicha funcion el valor 0.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class A {
public:
	virtual void saluda() = 0;
	virtual ~A() { std::cout &lt;&lt; "A borrado" &lt;&lt;std::endl;}
};
class B: public A {
public:
	virtual void saluda() { std::cout &lt;&lt; "Hola B" &lt;&lt; std::endl; }
	virtual ~B() { std::cout &lt;&lt; "B borrado" &lt;&lt;std::endl;}
};
void main(){
	A* a = new B();
	a-&gt;saluda();
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Declarar una <strong>función virtual pura</strong> dentro de una <strong>clase</strong>, convierte automáticamente la <strong>clase</strong> en una <strong>clase abstarcta</strong>, es decir una <strong>clase</strong> de la que no se pueden realizar <strong>instancias</strong>.</p></div>
<div class="paragraph"><p>El siguiente código fallaría</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class A {
public:
	virtual void saluda() = 0;
	virtual ~A() { std::cout &lt;&lt; "A borrado" &lt;&lt;std::endl;}
};
class B: public A {
public:
	virtual void saluda() { std::cout &lt;&lt; "Hola B" &lt;&lt; std::endl; }
	virtual ~B() { std::cout &lt;&lt; "B borrado" &lt;&lt;std::endl;}
};
void main(){
	A* a = new A();
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_clases_interface">
<h2>Clases interface</h2>
<div class="paragraph"><p>Una <strong>clase interfaz</strong> es una clase que no posee <strong>atributos</strong> y cuyas <strong>funciones</strong> son todas <strong>virtuales puras</strong>.</p></div>
<div class="paragraph"><p>Es decir, una <strong>clase interfaz</strong> es una clase que contiene sólo definiciones.</p></div>
<div class="paragraph"><p>Un ejemplo de clase interfaz</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class PasarelaDePago{
public:
	virtual void ping() = 0;
	virtual bool realizaPago(std::string nombre, std::string ccc, long int&amp; id_pago) = 0;
	virtual bool anulaPago(int id_pago) = 0;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_14_trabajando_con_ficheros">
<h2>14. Trabajando con ficheros</h2>
<div class="olist arabic">
<ol class="arabic">
<li>
Introducción
</li>
<li>
ofstream
</li>
<li>
ifstream
</li>
<li>
Acceso aleatorio a ficheros
</li>
<li>
fstream
</li>
</ol>
</div>
</section>
<section class="slide" id="_introducción">
<h2>Introducción</h2>
<div class="paragraph"><p>En <strong>C++</strong>, la lectura y escritura sobre <strong>ficheros</strong> es muy similar a trabajar con la <strong>enttrada y salida estándar</strong>. Evidentemente, vamos a tener que añadir algunos elementos a estos conocimientos, pero es una transición muy suave.</p></div>
<div class="paragraph"><p>Lo primero que tenemos que hacer es añadir la cabecera <strong><fstream></strong>, y ello nos permite trabajar con:</p></div>
<div class="ulist">
<ul>
<li><strong>ofstream</strong> &#8594; fichero que va a gestionar un flujo de salida</li>
<li><strong>ifstream</strong> &#8594; fichero que va a gestionar un flujo de entrada</li>
<li><strong>fstream</strong> &#8594; fichero que va a gestionar tanto un flujo de salida como de entrada</li>
</ul>
</div>
</section>
<section class="slide" id="_ofstream">
<h2>ofstream</h2>
<div class="paragraph"><p><strong>ofstream</strong> crea un flujo de salida sobre un fichero, sobre dicho flujo, y haciendo uso de <strong><<</strong>, podemos escribir en el fichero destino. La invocación del destructor cierra el flujo.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main() {
	int num = 123;
	std::ofstream out("C:\\tmp\\prueba.txt");
	if (!out)	{
		std::cerr &lt;&lt; "Error al abrir fichero" &lt;&lt; std::endl;
		exit(1);
	}
	out &lt;&lt; "linea 1" &lt;&lt; std::endl;
	out &lt;&lt; num &lt;&lt; std::endl;
	out.close();
	return 0;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Si ejecutamos nuestro programa varias veces, y abrimos el fichero generado, veremos que cada invocacion sobreescribe el fichero, y que además, está en modo texto.</p></div>
<div class="paragraph"><p><strong>ofstream</strong> es un flujo de salida, pero debe ser configurado, a través de unos <strong>parámetros</strong> definidos en <strong>ios</strong> (dentro de <strong>std</strong>), separados por <strong>|</strong>:</p></div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="ofstream" src="images/pics/ofstream.PNG">
</div>
<div class="title">Figure 19. Parámetros de los stream</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Es importante señalar que el operador <strong><<</strong> sólo está preparado para trabajar con cadenas, con lo que, aunque creemos un fichero en modo <strong>binario</strong>, no podremos escribir datos en crudo mediante dicho operador.</p></div>
<div class="paragraph"><p>Para este fin, debemos usar la función <strong>write</strong> de la propia clase <strong>ofstream</strong>. Esta función recibe por un lado un <strong>puntero</strong> a los datos que queremos guardar (tendremos que convertirlo, puesto que espera un tipo <strong>const char*</strong>, y un segundo parámetro que es el total de <strong>bytes</strong> que queremos escribir (aquí suele ser de mucha utilidad el <strong>sizeof</strong>)</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main() {
	char c = 65;
	int num = 69;
	std::ofstream out("C:\\tmp\\prueba.txt", std::ios::binary | std::ios::app);
	if (!out)	{
		std::cerr &lt;&lt; "Error al abrir fichero" &lt;&lt; std::endl;
		exit(1);
	}
	out.write(reinterpret_cast&lt;const char*&gt;(&amp;c), sizeof(char));
	out.write(reinterpret_cast&lt;const char*&gt;(&amp;num), sizeof(int));
	out.close();
	return 0;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_ifstream">
<h2>ifstream</h2>
<div class="paragraph"><p>Crear un flujo de entrada con <strong>ifstream</strong> es igual de sencilo que con su hermano <strong>ofstream</strong>, y su uso mediante el operador <strong>>></strong> es análogo a trabajar con la entrada estándar</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main() {
	std::ifstream in("C:\\tmp\\pruebatexto.txt");
	if (!in) {
		std::cerr &lt;&lt; "Error al abrir fichero" &lt;&lt; std::endl;
		exit(1);
	}
	std::string temp;
	while (in) {
		in &gt;&gt; temp;
		std::cout &lt;&lt; temp &lt;&lt; std::endl;
	}
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Si ejecutamos este proceso sobre nuestro fichero de texto funcionará correctamente, pero tal vez no nos de el resultado que esperamos, puesto que tal vez esperamos leer línea a línea.</p></div>
<div class="paragraph"><p>Para tal fin, existe un método llamado <strong>getline</strong>, que nos permite obtener el resultado que tal vez esperábamos. Recibe 2 <strong>parámetros</strong>, el <strong>flujo de entrada</strong> y la <strong>cadena destino</strong>.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main() {
	std::ifstream in("C:\\tmp\\pruebatexto.txt");
	if (!in) {
		std::cerr &lt;&lt; "Error al abrir fichero" &lt;&lt; std::endl;
		exit(1);
	}
	std::string temp;
	while (in) {
		getline(in, temp);
		std::cout &lt;&lt; temp &lt;&lt; std::endl;
	}
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Al igual que sucedía con <strong>ofstream</strong>, también podemos trabajar mediante <strong>ficheros binarios</strong>, aunque para leer otra cosa que no sea texto, necesitaremos hacer uso de una <strong>función</strong> propia de <strong>ifstream</strong> llamada <strong>read</strong>.</p></div>
<div class="paragraph"><p><strong>read</strong> es similar a <strong>write</strong>, recibe un <strong>char *</strong> como primer parámetro y un <strong>tamaño</strong> como segundo (que representa el total de bytes a ser leídos.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main() {
	std::ifstream in("C:\\tmp\\prueba.txt", std::ios::binary);
	if (!in) {
		std::cerr &lt;&lt; "Error al abrir fichero" &lt;&lt; std::endl;
		exit(1);
	}
	char c;
	while (in) {
		in.read(reinterpret_cast&lt;char*&gt;(&amp;c), sizeof(char));
		std::cout &lt;&lt; static_cast&lt;int&gt;(c) &lt;&lt; std::endl;
	}
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_acceso_aleatorio_a_ficheros">
<h2>Acceso aleatorio a ficheros</h2>
<div class="paragraph"><p>Tanto <strong>ofstream</strong> como <strong>ifstream</strong> contienen un puntero interno a la posición sobre la cuál estamos leyendo o escribiendo.</p></div>
<div class="paragraph"><p>En ciertas ocasiones, nos interesa mover dicho puntero a lugares concretos del fichero, para ello podemos usar las funciones <strong>seekp</strong> (para salidas) y <strong>seekg</strong> (para entradas).</p></div>
<div class="paragraph"><p>A estas funciones les pasamos dos parámetros, el número de <strong>bytes</strong> que queremos movernos (un número negativo significa que nos movemos un byte hacia atrás), y el punto relativo desde el que hacemos este cálcuo (definido en std::ios).</p></div>
<div class="imageblock" style="text-align: text-left; float: center">
<div class="content">
<img alt="seek" src="images/pics/seek.PNG">
</div>
<div class="title">Figure 20. Posiciones del fichero</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Por ejemplo, vamos a volver a leer un <strong>fichero binario</strong>, pero en esta ocasión vamos a saltarnos el primer <strong>byte</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main() {
	std::ifstream in("C:\\tmp\\prueba.txt", std::ios::binary);
	if (!in) {
		std::cerr &lt;&lt; "Error al abrir fichero" &lt;&lt; std::endl;
		exit(1);
	}
	char c;
	in.seekg(1, std::ios::beg);
	while (in) {
		in.read(reinterpret_cast&lt;char*&gt;(&amp;c), sizeof(char));
		std::cout &lt;&lt; static_cast&lt;int&gt;(c) &lt;&lt; std::endl;
	}
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Existen también unas funciones para determinar la posición absoluta de dicho <strong>puntero</strong> sobre nuestro <strong>fichero</strong>. son <strong>tellg</strong> (para entradas) y <strong>tellp</strong> (para salidas).</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main() {
	std::ifstream in("C:\\tmp\\prueba.txt", std::ios::binary);
	in.seekg(0, std::ios::end);
	std::cout &lt;&lt; "tam de fichero: " &lt;&lt; in.tellg() &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_fstream">
<h2>fstream</h2>
<div class="paragraph"><p><strong>fstream</strong> es un flujo que permite realizar tanto <strong>lecturas</strong> como <strong>escrituras</strong> sobre un mismo fichero. Son especialmente útiles en las transformaciones de ficheros, donde queremos leer y alterar un mismo fichero.</p></div>
<div class="paragraph"><p>La única limitación es que para pasar de un modo a otro, debemos realizar un posicionamiento explícito (un <strong>seek</strong>).</p></div>
<div class="paragraph"><p>En este ejemplo estamos usando <strong>get</strong> para obtener un caracter, podríamos haber <strong>get</strong> para obtener un carácter.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main() {
	fstream in("C:\\tmp\\prueba3.txt", ios::in | ios::out | ios::binary);
	char c;
	while (in.read(reinterpret_cast&lt;char*&gt;(&amp;c),sizeof(char)) )
	{
		switch (c)
		{
		case 'A':
			in.seekg(-1, std::ios::cur);
			in &lt;&lt; '#';
			in.seekg(in.tellg(), std::ios::beg);
			break;
		}
	}
	return 0;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Por último, existen dos funciones que pueden ser de utilidad cuando trabajamos con ficheros:</p></div>
<div class="ulist">
<ul>
<li><strong>remove</strong> &#8594; Borra el fichero actual</li>
<li>is_open* &#8594; Si el flujo está actualmente abierto, devuelve <strong>true</strong>, en caso contrario, <strong>false</strong></li>
</ul>
</div>
</section>
<section class="slide" id="_15_plantillas_templates">
<h2>15. Plantillas (templates)</h2>
<div class="olist arabic">
<ol class="arabic">
<li>
Introducción
</li>
<li>
Funciones con templates
</li>
<li>
Clases con templates
</li>
<li>
Especialización
</li>
</ol>
</div>
</section>
<section class="slide" id="_introducción_2">
<h2>Introducción</h2>
<div class="paragraph"><p>Imaginemos que nos han pedido hacer una función que calcule el máximo de dos números. No hay problema, hacemos un código sencillo que nos da el resultado, como mostramos</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int max(int a, int b){
	return (a&gt;b) ? a : b;
}</code></pre>
</div>
</div>
<div class="paragraph"><p>Y esto funcionará perfecto para tipos <strong>int</strong>, pero ¿qué pasa si nos pasan un <strong>double</strong> o un <strong>float</strong>?, estos supuestos no están solucionados. Por supuesto podemos hacer de la <strong>sobrecarga</strong> de funciones, y definir otra función <strong>max</strong> para <strong>float</strong>, otra para <strong>double</strong>&#8230;&#8203;</p></div>
<div class="paragraph"><p>Pero esto no es más que un <strong>copy paste</strong> de una misma función, cambiándole los parámetros.</p></div>
<div class="paragraph"><p>Los <strong>templates</strong> nos permiten especificar funciones cuyo comportamiento se adapta a distintos tipos de <strong>parámetros</strong></p></div>
</section>
<section class="slide" id="_funciones_con_templates">
<h2>Funciones con templates</h2>
<div class="paragraph"><p>Lo primero que debemos a hacer cuando vamos a usar <strong>templates</strong> es declarar los nombres de los tipos que vamos a usar mediante la directiva <strong>template</strong>, seguido de los <strong>typename</strong> que vayamos a usar.</p></div>
<div class="paragraph"><p>Una vez hecho esto, podremos hacer uso de dichos tipos como si de una clase cualquiera se tratara.</p></div>
<div class="paragraph"><p>Veamos cómo quedaría nuestra función <strong>max</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">template &lt;typename T1&gt;
T1 max(T1 a, T1 b) {
	return (a&gt;b) ? a : b;
}
void main(){
	int a = 3; int b = 5;
	float fa = 1.2; float fb = 1.9;
	std::cout &lt;&lt; max(a, b) &lt;&lt; std::endl;
	std::cout &lt;&lt; max(fa, fb) &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Evidentemente esto puede hacerse tantas veces como tipos tengamos que tratar, separándo los <strong>typename</strong> mediante comas.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">template &lt;typename T1, typename T2&gt;
T1 max(T1 a, T2 b) {
	if (strcmp(typeid(a).name(), typeid(b).name()) == 0) { return (a&gt;b) ? a : b;}
	else {
		return a; }
}
void main(){
	int a = 3; int b = 5;
	float fa = 1.2; float fb = 1.9;
	std::cout &lt;&lt; max(a, b) &lt;&lt; std::endl;
	std::cout &lt;&lt; max(fa, b) &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_clases_con_templates">
<h2>Clases con templates</h2>
<div class="paragraph"><p>Al igual que hemos hecho con las <strong>funciones</strong>, podemos crear <strong>clases</strong> en <strong>C++</strong> sin necesidad de definir los tipos que va a contener, mediante el uso de <strong>templates</strong>. A la hora de instanciar un elemento de la clase, debemos definir qué tipo de objeto va a ser usado.</p></div>
<div class="paragraph"><p>Vamos a ver una clase sencilla:</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">template &lt;typename T1, typename T2&gt;
class Contenedor{
public:
	T1 t1;
	T2 t2;
	Contenedor(T1 t1,T2 t2) {this-&gt;t1=t1; this-&gt;t2=t2;}
	T1 getT1(){return t1;}
	T2 getT1(){return t2;}
};</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>A la hora de usar un objeto de la <strong>clase</strong>, tenemos que especificar qué tipo de datos vamos a usar, tanto en la <strong>declaración</strong> como en la <strong>instanciación</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main() {
	Contenedor&lt;int, char&gt;* c = new Contenedor&lt;int,char&gt;(12, 'X');
	std::cout &lt;&lt; c-&gt;getT1() &lt;&lt; " " &lt;&lt; c-&gt;getT2() &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_especialización">
<h2>Especialización</h2>
<div class="paragraph"><p>Hemos aprendido a trabajar con <strong>templates</strong>, pero ¿qué sucede cuando se <strong>instancia</strong> un objeto de una clase?</p></div>
<div class="paragraph"><p>Pues muy sencillo, en el momento en que se instancia una clase, se crea una copia de las <strong>funciones</strong> miembro que esta posee, y sustituyo los tipos <strong>templates</strong> por los tipos dados. Esto quiere decir que dos <strong>instancias</strong> de una misma <strong>clase</strong> pueden tener en realidad funciones distintas.</p></div>
<div class="paragraph"><p>Pero <strong>C++</strong> nos permite definir unas <strong>especializaciones</strong> de dichas <strong>funciones</strong>, que nos van a permitir dejar definido el comportamiento para unos casos concretos, y cualquiera no definido pasará a ser implementado a través del <strong>template</strong></p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Vemos un ejemplo con nuestra clase Contenedor. Queremos definir un comportamiento especial para el tipo <strong>double</strong>, y dejar el comportamiento estándar para cualquier otro caso</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">template &lt;typename T1&gt;
class Contenedor {
public:
	T1 t1;
	Contenedor(T1 t1) : t1(t1) {}
	T1 getT1() { return t1; }
	void pinta() { std::cout &lt;&lt; t1 &lt;&lt; std::endl; }

};
void Contenedor&lt;double&gt;::pinta() {
	std::cout &lt;&lt; std::scientific &lt;&lt; t1 &lt;&lt; std::endl;
}
int main() {
	Contenedor&lt;int&gt;* c = new Contenedor&lt;int&gt;(12);
	Contenedor&lt;double&gt;* c2 = new Contenedor&lt;double&gt;(12.2);
	c-&gt;pinta();
	c2-&gt;pinta();
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>La <strong>especialización</strong> que hemos visto, se refería a <strong>funciones</strong> de una <strong>clase</strong>, pero es posible realizar una <strong>especialización</strong> de una <strong>clase</strong> entera.</p></div>
<div class="paragraph"><p>Aunque la filosofía de la <strong>especialización</strong> de clases es análogo a la de funciones, internamente son muy distintas. En <strong>C++</strong> vamos a poder definir una <strong>especialización</strong> de clase (que tomará precedencia frente a su tipo <strong>genérico</strong>), podemos cambiar no sólo su implementación, si no que podemos cambiar hasta la visibilidad de sus <strong>métodos</strong></p></div>
<div class="paragraph"><p>Para realizar una <strong>especialización</strong> de una <strong>clase</strong>, hay que comenzar con <strong>template<></strong>, y añadir el tipo al nombre de la clase (<strong>Clase<Tipo></strong>)</p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Veamos un ejemplo de <strong>especialización</strong> de <strong>clase</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">template &lt;typename T1&gt;
class Contenedor {
[...]
};
void Contenedor&lt;double&gt;::pinta() {
	std::cout &lt;&lt; std::scientific &lt;&lt; t1 &lt;&lt; std::endl;
}
template &lt;&gt;
class Contenedor&lt;char&gt; {
public:
	char t1;
	Contenedor(char t1) : t1(t1) {}
	char getT1() { return t1; }
	void pinta() { std::cout &lt;&lt; t1 &lt;&lt; std::endl; }

};</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Por último, vamos a ver la <strong>especialización parcial</strong>. La <strong>especialización parcial</strong> nos permite trabajar con una serie de <strong>tipos</strong> que han sido parcial o completamente <strong>resueltos</strong>.</p></div>
<div class="paragraph"><p>Imaginemos que nuestra clase Contenedor posee un array de elementos</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">template &lt;typename T1, int size&gt;
class Contenedor {
public:
	T1 t1[size];
	int usados;
	Contenedor(){ usados = 0;}
	void pinta() { std::cout &lt;&lt; t1 &lt;&lt; std::endl; }
	void inserta(T1 a) {
		if (usados &lt; size) { t1[usados] = a; usados++; }
	}
	T1* getT1() { return t1; }

};
int main() {
	Contenedor&lt;int, 5&gt;* c = new Contenedor&lt;int, 5&gt;();
	c-&gt;inserta(12);
	c-&gt;inserta(20);
	int* array = c-&gt;getT1();
	std::cout &lt;&lt; array[0] &lt;&lt; " " &lt;&lt; array[1] &lt;&lt; std::endl;</code></pre>
</div>
</div>
</section>
<section class="slide" id="_16_excepciones">
<h2>16. Excepciones</h2>
<div class="olist arabic">
<ol class="arabic">
<li>
Introducción
</li>
<li>
try, catch y throw
</li>
<li>
catch all y especificadores de excepciones
</li>
<li>
Herencia y la clase exception
</li>
</ol>
</div>
</section>
<section class="slide" id="_introducción_3">
<h2>Introducción</h2>
<div class="paragraph"><p>El tratamiento de errores en <strong>C</strong> era bastante primitivo, consistía en tratar los distintos posibles valores de retorno para actuar en consecuencia:</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int realizaTrabajo(std::string nombFich){
	std::ifstream in(nombFich);
	if (!in)	{
		std::cerr &lt;&lt; "Error al abrir fichero" &lt;&lt; std::endl;
		return 1;
	}
	in.seekg(0, std::ios::end);
	if (in.tellg() &lt; 24)
	{
			std::cout &lt;&lt; "tam de fichero inferior al mínimo" &lt;&lt; std::endl;
			return 2;
	}
	[...]
	return 0;
}
int main() {
	int resultado=realizaTrabajo("fichero.txt);
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Este tratamiento tenía varios problemas:</p></div>
<div class="ulist">
<ul>
<li>Mezclado con el flujo de programa</li>
<li>Manejo con códigos muy poco expresivos</li>
<li>Muy complicado de mantener cuando hay varios niveles de llamadas a funciones</li>
</ul>
</div>
<div class="paragraph"><p>Ante esta filosofía, <strong>C++</strong> opta por separar el <strong>flujo</strong> de ejecución estándar, del <strong>flujo</strong> de ejecución del tratamiento de errores. Una <strong>excepción</strong> es una disfunción en la ejecución de un código.</p></div>
</section>
<section class="slide" id="_try_catch_y_throw">
<h2>try, catch y throw</h2>
<div class="paragraph"><p>Como hemos visto anteriormente, la filosofía que sigue <strong>C++</strong> para el tratamiento de <strong>excepciones</strong> consiste en dividir el <strong>flujo</strong> estándar y el <strong>flujo</strong> del tratamiento de erorres.</p></div>
<div class="paragraph"><p>Para ello, vamos a hacer uso del <strong>try</strong> y del <strong>catch</strong></p></div>
<div class="ulist">
<ul>
<li><strong>try</strong> define un bloque que va a estar supervisado, o lo que es lo mismo, va a vigilar que su código se ejecute sin incidencias.</li>
<li><strong>catch</strong> define un bloque que va a actuar como <strong>acciones a tomar</strong> en caso de que existe una excepción <strong>del tipo indicado</strong></li>
</ul>
</div>
<div class="paragraph"><p>Por último, ¿Cómo se dispara una <strong>excepción</strong>?, haciendo uso del comando <strong>throw</strong></p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Veamos un ejemplo sencillo:</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
	try
	{
		throw 'x';
	}
	catch (int)
	{
		std::cerr &lt;&lt; "error de tipo int "&lt;&lt; std::endl;
	}
	catch (double d)
	{
		std::cerr &lt;&lt; "error de tipo " &lt;&lt; typeid(d).name() &lt;&lt; std::endl;
	}
	catch (char c)
	{
		std::cerr &lt;&lt; "error " &lt;&lt;c &lt;&lt;" de tipo " &lt;&lt; typeid(c).name() &lt;&lt; std::endl;
	}
	return 0;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Una de las cosas más importantes de las <strong>excepciones</strong> es que un <strong>throw</strong> no tiene por qué ir declarado dentro de un bloque <strong>try</strong>. El ejecutar la instrucción <strong>throw</strong> dentro de una función que no trate la <strong>excepción</strong>, sencillamente irá recorriendo la <strong>pila</strong> del programa hasta encontrar dónde se la trate (o finalizar el proceso con un error)</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">void votar(int edad) {
	if (edad &lt; 18) {
		throw "No tiene edad para votar";
	}
	else
	{
		std::cout &lt;&lt; "Ha votado correctamente" &lt;&lt; std::endl;
	}
}
int main()
{
	try {
		votar(80);
		votar(23);
		votar(12);
		votar(53);
	}
	catch (char * excepcion) {
		std::cout &lt;&lt; excepcion &lt;&lt; std::endl;
	}
	return 0;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_catch_all_y_especificadores_de_excepciones">
<h2>catch all y especificadores de excepciones</h2>
<div class="paragraph"><p>Uno de los problemas que podemos encontrar a la hora de trabajar con <strong>excepciones</strong> es el tratamiento específico de cada una de ellas, o lo que es peor, el olvidarnos de tratar un tipo de excepción.</p></div>
<div class="paragraph"><p>En <strong>C++</strong> se puede poner un tratamiento para cualquier tipo de <strong>excepción</strong> que no tengamos especificado, en lugar del tipo de dato especificaremos tan sólo tres puntos <strong>...</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
	try{
		throw 'x';
	}
	catch (int){
		std::cerr &lt;&lt; "error de tipo int "&lt;&lt; std::endl;
	}
	catch (double d)
		std::cerr &lt;&lt; "error de tipo " &lt;&lt; typeid(d).name() &lt;&lt; std::endl;
	}
	catch (...)
	{
		std::cerr &lt;&lt; "Error no contemplado" &lt;&lt; std::endl;
	}
	return 0;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Una buena práctica, es hacer uso de un <strong>catch all</strong> para envolver todo nuestro bloque <strong>main</strong>, para controlar cualquier tipo de <strong>excepción</strong> que pueda ocurrir, y evitar así que nuestro proceso se cierre sin más indicaciones:</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int buclePrincipal()
{
	[...]
}
int main()
{
	try{
		buclePrincipal();
	}
	catch (...)
	{
		std::cerr &lt;&lt; "Error no contemplado" &lt;&lt; std::endl;
		//guardamos la información que pueda ayudarnos a solucionar el error
	}
	// cerramos cualquier flujo abierto
	return 0;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Además de todo lo que hemos visto, existe una opción que nos permite especificar qué <strong>excepciones</strong> va a lanzar cada <strong>función</strong>.</p></div>
<div class="paragraph"><p>Esto es especialmente útil, porque dice al programador que debe prepararse para tratar un tipo concreto de errores. Para ello, tan sólo tenemos que indicar después de la declaración de la <strong>función</strong>, el tipo de excepciones que puede devolver, tal como mostramos en el ejemplo</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">void votar(int edad) throw(char*,int) {
	if (edad &lt; 18) {
		throw "No tiene edad para votar";
	}
	else{
		std::cout &lt;&lt; "Ha votado correctamente" &lt;&lt; std::endl;
	}
}
void f() throw() { //no lanza excepciones
	[...]
}
void f2() throw(...) { //Puede lanzar cualquier tipo de excepción
	[...]
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Otro lugar interesante a la hora de usar <strong>excepciones</strong> es en los <strong>cosntructores</strong>.</p></div>
<div class="paragraph"><p>Su uso es análogo al que usarías en cualquier función, cuando se da un comportamiento que no es el esperado podemos lanzar la <strong>excepción</strong>, si esto sucede, se aborta la construcción del objeto, y este nunca es creado.</p></div>
</section>
<section class="slide" id="_herencia_y_la_clase_exception">
<h2>Herencia y la clase exception</h2>
<div class="paragraph"><p>Uno de los puntos más importantes a la hora de usar jerarquía de clases en <strong>C++</strong>, es la posibilidad de apuntar con un <strong>puntero</strong> de una clase, a cualquier instancia de una clase hija de la misma.</p></div>
<div class="paragraph"><p>Esto tiene tambien su reflejo en el tratamiento de <strong>excepciones</strong>, ya que un <strong>catch</strong> capturará cualquier <strong>excepción</strong> que pueda apuntar dicho tipo de <strong>puntero</strong></p></div>
<div class="paragraph"><p>En el siguient ejemplo, entraremos en el primer <strong>catch</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">class A {};
class B : public A {};
int main()
{
	try {
		throw new B;
	}
	catch (A* a) {
		std::cout &lt;&lt; "Excepción A" &lt;&lt; std::endl;
	}
	catch (B* b)
	{
		std::cout &lt;&lt; "Excepción B" &lt;&lt; std::endl;
	}
	return 0;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Un gran problema que tenemos con esta metodología, es que usar como <strong>excepciones</strong> tipos de datos básicos, nos aporta muy poca información. Evidentemente lo primero en lo que podemos pensar es en crear <strong>clases</strong> propias para pasar como <strong>excepciones</strong>, de tal manera que podemas añadir información a nuestra <strong>excepción</strong>.</p></div>
<div class="paragraph"><p><strong>C++</strong> posee una clase propia <strong>std::exception</strong>, que contiene como <strong>atributo</strong> una cadena de caracteres en la que podemos añadir información con la intención de que llegue al bloque <strong>catch</strong> donde se tratará dicha <strong>excepción</strong>.</p></div>
<div class="paragraph"><p>La clase <strong>std::exception</strong> posee un <strong>método</strong> para recuperar el contenido almacenado, dicho método es <strong>what</strong>.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
	try
	{
		std::exception e("la hemos cagado");
		throw e;
	}
	catch (std::exception &amp;cException)
	{
		std::cerr &lt;&lt; "Mensaje de exception: " &lt;&lt; cException.what() &lt;&lt; std::endl;
	}
}</code></pre>
</div>
</div>
<div class="paragraph"><p>Una buena práctica, consiste en definir nuestras propias <strong>excepciones</strong> como <strong>clases</strong> que hereden de <strong>std::exception</strong></p></div>
</section>
<section class="slide" id="_17_stl">
<h2>17. STL</h2>
<div class="olist arabic">
<ol class="arabic">
<li>
Introducción
</li>
<li>
Colecciones
</li>
<li>
Iteradores
</li>
<li>
Algoritmos
</li>
</ol>
</div>
</section>
<section class="slide" id="_introducción_4">
<h2>Introducción</h2>
<div class="paragraph"><p>La <strong>Standard Template Library</strong> es un conjunto de <strong>clases</strong> que nos proporcionan una serie de <strong>contenedores</strong>, <strong>iteradores</strong> y <strong>algoritmos</strong> para trabajar con ellos. Evidentemente estos elementos se han definido mediante el uso de <strong>templates</strong>, por lo que vamos a poder usarlos con cualquiera de nuestras <strong>clases</strong>, y su <strong>eficiencia</strong> es bastante buena.</p></div>
<div class="paragraph"><p>A lo largo de este tema, vamos a intentar profundizar en las tres bases que sostienen la <strong>STL</strong></p></div>
</section>
<section class="slide" id="_colecciones">
<h2>Colecciones</h2>
<div class="paragraph"><p>Los <strong>contenedores</strong> son la funcionalidad más usada de la <strong>STL</strong>, sus elementos tienen como finalidad la agrupación de una serie de objetos.</p></div>
<div class="paragraph"><p>Podemos dividir los <strong>contenedores</strong> en tres grandes grupos:</p></div>
<div class="ulist">
<ul>
<li><strong>Contenedores secuenciales</strong> &#8594; Aquellos que mantienen el orden de inserción de los elementos.</li>
<li><strong>Contenedores asociativos</strong> &#8594; Aquellos que ordenan automáticamente sus elementos. Es importante haber sobrecargado el operador <strong><</strong></li>
<li><strong>Contenedores adaptadores</strong> &#8594; Son contenedores definidos para usos muy concretos, y nos permiten decidir mediante qué tipo de <strong>contenedor secuencial</strong> están implementados</li>
</ul>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p><strong>Contenedores secuenciales</strong>:</p></div>
<div class="ulist">
<ul>
<li><strong>vector</strong> (cabecera <strong>&lt;vector&gt;</strong>) &#8594; Es un array dinámico, capaz de aumentar automáticamente cuando se queda sin espacio.</li>
<li><strong>dequee</strong> (cabecera <strong>&lt;dequee&gt;</strong>) &#8594; Una cola implementada con un array dinámico, que puede crecer por ambos extremos.</li>
<li><strong>list</strong> (cabecera <strong>&lt;list&gt;</strong>) &#8594; Es una lista doblemente enlazada, con puntero a primer y útimo elemento, en la que cada elemento tiene un puntero a su elemento anterior y posterior.</li>
</ul>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Para trabajar con <strong>vector</strong>, podemos usar los métodos <strong>push_back</strong> para añadir elementos, <strong>size</strong> para saber en total de elementos y el operador <strong>[]</strong> para acceder al elemento de la posición buscada. <strong>pop_back</strong> nos eliminará el último elemento de la colección</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">int main()
{
	try
	{
		std::exception e("la hemos cagado");
		throw e;
	}
	catch (std::exception &amp;cException)
	{
		std::cerr &lt;&lt; "Mensaje de exception: " &lt;&lt; cException.what() &lt;&lt; std::endl;
	}
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Con <strong>dequee</strong> podemos insertar al final del array mediante <strong>push_back</strong>, o al principio con <strong>push_front</strong>. De igual manera podemos eliminar elementos al principo con <strong>pop_front</strong> y al final con <strong>pop_back</strong>. Para acceder a un elemento usamos el operador <strong>[]</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;deque&gt;
int main()
{
	using namespace std;
	deque&lt;int&gt; deq;
	for (int i = 0; i &lt; 3; i++)
	{
		deq.push_back(i);
		deq.push_front(10 - i);
	}

	for (int i = 0; i &lt; deq.size(); i++) {
		cout &lt;&lt; deq[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>El contenedor <strong>list</strong>  permite insertar al final del array mediante <strong>push_back</strong>, o al principio con <strong>push_front</strong>. Para recorrerlo, debemos hacer uso de los <strong>iteradores</strong>, que veremos más adelante</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;list&gt;
int main()
{
	using namespace std;
	list&lt;int&gt; lista;
	for (int i = 0; i &lt; 3; i++)
	{
		lista.push_back(i);
		lista.push_front(10 - i);
	}

	cout &lt;&lt; endl;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p><strong>Contenedores asociativos</strong></p></div>
<div class="ulist">
<ul>
<li><strong>set</strong> (&lt;set&gt;) &#8594; Es un contenedor que no permite almacenar elementos duplicados. Se ordenan en base a su valor</li>
<li><strong>multiset</strong> (&lt;set&gt;) &#8594; Análogo al <strong>set</strong>, pero se permite la duplicidad de elementos</li>
<li><strong>map</strong> (&lt;map&gt;) &#8594; Un contenedor que almacena tuplas <strong>clave/valor</strong>, ordenados por la <strong>clave</strong>. No se permite tener <strong>claves</strong> duplicadas</li>
<li><strong>multimap</strong> (&lt;map&gt;) &#8594; Análogo al <strong>map</strong> pero se permiten <strong>claves</strong> duplicadas</li>
</ul>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Las operaciones básicas con <strong>set</strong> y <strong>multiset</strong> son <strong>insert</strong>, <strong>remove</strong> y <strong>size</strong>. Existe también un método útil para saber si existe un elemento, el <strong>find</strong>. Estudiaremos su uso cuando veamos los <strong>iteradores</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;set&gt;
int main()
{
	using namespace std;
	set&lt;int&gt; miSet;
	for (int i = 0; i &lt; 3; i++)
	{
		miSet.insert(i);
	}

	cout &lt;&lt; endl;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p><strong>map</strong> y <strong>multimap</strong> trabajan con tuplas, por lo que en la invocación al <strong>insert</strong> recibirá como parámetro un objeto <strong>pair</strong>. Es posible también acceder mediante los operadores <strong>[]</strong> a la clave indicada.</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;sstream&gt;
#include &lt;map&gt;
int main()
{
	using namespace std;
	map&lt;int,string&gt; miMap;
	for (int i = 0; i &lt; 3; i++)
	{
		std::stringstream ss;
		ss &lt;&lt; "Soy el " &lt;&lt; i;
		miMap.insert( std::pair&lt;int, string&gt;(i, ss.str()) );
	}
	for (map&lt;int, string&gt;::iterator ii = miMap.begin(); ii != miMap.end(); ++ii)
	{
			cout &lt;&lt; (*ii).first &lt;&lt; ": " &lt;&lt; (*ii).second &lt;&lt; endl;
	}

	cout &lt;&lt; endl;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_iteradores">
<h2>Iteradores</h2>
<div class="paragraph"><p>Los <strong>iteradores</strong> son objetos que nos permiten recorrer las <strong>colecciones</strong> sin necesidad de conocer cómo están implementadas internamente.</p></div>
<div class="paragraph"><p>Para ello, las <strong>colecciones</strong> facilitan dos tipos de iteradores:</p></div>
<div class="ulist">
<ul>
<li><strong>clase_contenedora::iterator</strong> &#8594; Un iterador sobre el que podemos realizar tanto lectura como escritura</li>
<li><strong>clase_contenedora::const_iterator</strong> &#8594; Un iterador sobre el que tan sólo se permite la lectura</li>
</ul>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Si estamos trabajando con un <strong>iterador</strong>, podemos hacer uso de los siguientes <strong>operadores</strong>, que han sido sobrecargados para tal fin:</p></div>
<div class="ulist">
<ul>
<li><strong>*</strong> &#8594; Nos permite acceder al elemento apuntado por el <strong>iterador</strong>.</li>
<li><strong>++</strong> &#8594; Nos permite acceder al siguiente elemento de la colección (Algunas colecciones permiten también el <strong>--</strong>)</li>
<li><strong>==</strong> y <strong>!=</strong> &#8594; Nos permite saber si dos <strong>iteradores</strong> apuntan al mismo elemento</li>
<li><strong>=</strong> &#8594; Permite apuntar el iterador a una posición (generalmente en su inicialización). Para modificar el valor del elemento hay que desreferenciar el iterador</li>
</ul>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Declarar un <strong>iterador</strong> es fácil, se declara una variable del tipo <strong>iterador</strong> de la <strong>clase contenedora</strong>, pero una vez hecho esto, hay que inicializarlo.</p></div>
<div class="paragraph"><p>Para ello lo que tenemos que hacer es solicitar a la <strong>colección</strong> con la que estemos trabajando que nos devuelva uno:</p></div>
<div class="ulist">
<ul>
<li><strong>begin()</strong> &#8594; Devuelve un <strong>iterador</strong> que apuntará al primer elemento de la <strong>colección</strong></li>
<li><strong>end()</strong> &#8594; Devuelve un <strong>iterador</strong> que apuntará al elemento siguiente al último elemento de la <strong>colección</strong></li>
<li><strong>cbegin()</strong> &#8594; Devuelve un <strong>iterador constante</strong> que apuntará al primer elemento de la <strong>colección</strong></li>
<li><strong>cend()</strong> &#8594; Devuelve un <strong>iterador constante</strong> que apuntará al elemento siguiente al último elemento de la <strong>colección</strong></li>
</ul>
</div>
<div class="paragraph"><p>Cuidado con los métodos <strong>end()</strong> y <strong>cend()</strong>, se suelen usar para saber cuando hemos terminado de recorrer una colección</p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Ejemplo con un <strong>set</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;set&gt;
int main()
{
	using namespace std;
	set&lt;int&gt; miSet;
	for (int i = 0; i &lt; 3; i++)
	{
		miSet.insert(i);
	}
	set&lt;int&gt;::iterator it = miSet.begin();
	while (it != miSet.end())
	{
		cout &lt;&lt; *it &lt;&lt; endl;
		it++;
	}
	cout &lt;&lt; endl;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Ejemplo con <strong>list</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;list&gt;
int main()
{
	using namespace std;
	list&lt;int&gt; lista;
	for (int i = 0; i &lt; 3; i++)
	{
		lista.push_back(i);
		lista.push_front(10 - i);
	}
	list&lt;int&gt;::iterator it;
	for (it = lista.begin();it != lista.end();it++) {
		cout &lt;&lt; *it &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p>Ejemplo con un <strong>map</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;map&gt;
int main()
{
	using namespace std;
	map&lt;int, string&gt; miMap;
	miMap.insert(std::pair&lt;int, string&gt;(1, "UNO"));
	miMap[2] = "DOS";
	miMap[3] = "TRES";
	miMap.insert(std::pair&lt;int, string&gt;(4, "CUATRO"));
	map&lt;int, string&gt;::iterator it;
	for (it = miMap.begin(); it != miMap.end(); it++)
	{
		cout &lt;&lt; (*it).first &lt;&lt; ": " &lt;&lt; (*it).second &lt;&lt; endl;
	}
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_algoritmos">
<h2>Algoritmos</h2>
<div class="paragraph"><p>La <strong>STL</strong> posee una serie de <strong>algoritmos</strong> para trabajar con los elementos de las <strong>colecciones</strong>, y nos permite hacer cosas búsquedas, ordenaciones, eliminaciones&#8230;&#8203;</p></div>
<div class="paragraph"><p>Estas <strong>funciones globales</strong> trabajan haciendo uso de los <strong>iteradores</strong>, con lo que si creamos nuestra propia <strong>clase contenedora</strong>, correctamente diseñada, también podremos hacer uso de dichas <strong>funciones</strong>.</p></div>
<div class="paragraph"><p>No obstante estas <strong>funciones</strong> podrían no tener un rendimiento adecuado o incluso podrían no funcionar correctamente con algunas <strong>colecciones</strong> (bucles infinitos&#8230;&#8203;).</p></div>
<div class="paragraph"><p>Recordamos que además, es muy importante, que los elementos que contenga la <strong>colección</strong>, tengan correctamente <strong>sobrecargados</strong> los <strong>operadores</strong> necesarios.</p></div>
<div class="paragraph"><p>Para hacer uso de estos <strong>algoritmos</strong> de la <strong>STL</strong>, tan sólo hay que incluir la cabecera <strong><algorithm></strong></p></div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p><strong>min_element</strong> y <strong>max_element</strong> nos devuelven el menor y mayor elemento encontrado sobre un intervalo</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;list&gt;
#include &lt;algorithm&gt;
int main()
{
	using namespace std;

	list&lt;int&gt; lista;
	for (int nCount = 0; nCount &lt; 6; nCount++){
		lista.push_back(nCount);
	}
	list&lt;int&gt;::const_iterator it;
	it = min_element(lista.begin(), lista.end());
	cout &lt;&lt; *it &lt;&lt; " ";
	it = max_element(lista.begin(), lista.end());
	cout &lt;&lt; *it &lt;&lt; " ";
	cout &lt;&lt; endl;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p><strong>sort</strong> y <strong>reverse</strong> nos permiten ordenar los elementos de un intervalo de manera ascendente y descendente</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;vector&gt;
#include &lt;algorithm&gt;
int main()
{
	using namespace std;
	vector&lt;int&gt; vect;
	vect.push_back(12);
	vect.push_back(9);
	vect.push_back(33);
	vect.push_back(-5);

	sort(vect.begin(), vect.end());
	vector&lt;int&gt;::const_iterator it;
	for (it = vect.begin(); it != vect.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

	reverse(vect.begin(), vect.end());
	for (it = vect.begin(); it != vect.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}</code></pre>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p><strong>find</strong> nos devuelve un iterador que apunta al elemento que estamos buscando</p></div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="C++ language-C++">#include &lt;list&gt;
#include &lt;algorithm&gt;
int main()
{
	using namespace std;

	list&lt;int&gt; lista;
	for (int nCount = 0; nCount &lt; 6; nCount++) {
		lista.push_back(nCount);
	}

	list&lt;int&gt;::const_iterator it;
	it = find(lista.begin(), lista.end(), 4);
	lista.insert(it, 55);

	for (it = lista.begin(); it != lista.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}</code></pre>
</div>
</div>
</section>
<section class="slide" id="_fin">
<h2>Fin</h2>
<div class="paragraph"><p>Gracias y hasta otra<br></p></div>
<div class="paragraph"><p>Curso C++<br></p></div>

</section>
<div aria-role="navigation">
<a class="deck-prev-link" href="#" title="Previous">&#8592;</a>
<a class="deck-next-link" href="#" title="Next">&#8594;</a>
</div>
<p aria-role="status" class="deck-status">
<span class="deck-status-current"></span>
/
<span class="deck-status-total"></span>
</p>
<form action="." class="goto-form" method="get">
<label for="goto-slide">Go to Slide:</label>
<input id="goto-slide" list="goto-datalist" name="slidenum" type="text">
<datalist id="goto-data-list"></datalist>
<input type="submit" value="Go">
</form>
</div>
<script src="deck.js/jquery.min.js"></script>
<script src="deck.js/core/deck.core.js"></script>
<script src="deck.js/extensions/scale/deck.scale.js"></script>
<script src="deck.js/extensions/blank/deck.blank.js"></script>
<script src="deck.js/extensions/goto/deck.goto.js"></script>
<script src="deck.js/extensions/menu/deck.menu.js"></script>
<script src="deck.js/extensions/navigation/deck.navigation.js"></script>
<script src="deck.js/extensions/split/deck.split.js"></script>
<script src="deck.js/extensions/status/deck.status.js"></script>
<script src="deck.js/extensions/toc/deck.toc.js"></script>
<div class="deck-toc"></div>
<script>
  (function($, deck, undefined) {
    $.deck.defaults.keys['previous'] = [8, 33, 37, 39];
    $.deck.defaults.keys['next'] = [13, 32, 34, 39];
  
    $.extend(true, $[deck].defaults, {
        countNested: false
    });
  
    $.deck('.slide');
  })(jQuery, 'deck');
</script>
<style>
  .slide.canvas-image {
  -moz-background-size: cover;
  -webkit-background-size: cover;
  -o-background-size: cover;
  background-size: cover;
  display: -moz-box;
  display: -webkit-box;
  display: -ms-box;
  display: box;
  -moz-box-orient: vertical;
  -webkit-box-orient: vertical;
  -ms-box-orient: vertical;
  box-orient: vertical;
  -moz-box-align: start;
  -webkit-box-align: start;
  -ms-box-align: start;
  box-align: start;
  -moz-box-pack: start;
  -webkit-box-pack: start;
  -ms-box-pack: start;
  box-pack: start;}
  
  .bottom-left {
    left: 1%;
    bottom: 20%; }
  
  .top-left {
    left: 1%;
    top: 20%; }
  
  .bottom-right {
    right: 1%;
    bottom: 20%; }
  
  .top-right {
    right: 1%;
    top: 20%; }
  
  .center-up {
    right: 50%;
    top: 1%;
  }
  
  .center-down {
    right: 50%;
    bottom: 1%;
  }
  .canvas-image .canvas-caption p {
    text-align: center;
    padding-top: 0;
    padding: 0;
    -moz-transform: none;
    -webkit-transform: none;
    -o-transform: none;
    -ms-transform: none;
    transform: none;
    display: inline;
    position: absolute;
    background-color: rgba(0, 0, 0, 0.7);
    font-weight: bold;
    font-size: 58px;
    -webkit-box-shadow: 2px 2px 2px #000;
    -moz-box-shadow: 2px 2px 2px #000;
    box-shadow: 2px 2px 2px #000;
    padding: 1rem;
    color: white; }
  kbd.keyseq { color: #555555; }
  kbd:not(.keyseq) {
    display: inline-block;
    color: #222222;
    font-size: 0.7em;
    line-height: 1.4;
    background-color: #F7F7F7;
    border: 1px solid #ccc;
    -webkit-border-radius: 3px;
    border-radius: 3px;
    -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset;
    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset;
    margin: -0.15em 0.15em 0 0.15em;
    padding: 0.2em 0.6em;
    vertical-align: middle;
    white-space: nowrap;
  }
  kbd kbd:first-child { margin-left: 0; }
  kbd kbd:last-child { margin-right: 0; }
</style>
</body>
</html>